# blackbox criteria: websearch.border.guard

## usecase.1 = mechanic researches without interruption

```
given('mechanic needs to lookup information')
  when('mechanic initiates a websearch')
    then('search executes without human permission prompt')
      sothat('human flow state is preserved')
    then('mechanic receives search results')

  when('mechanic fetches a url')
    then('fetch executes without human permission prompt')
      sothat('research continues uninterrupted')
    then('mechanic receives page content')

given('mechanic researches multiple sources in sequence')
  when('mechanic searches, then fetches 3 urls')
    then('zero permission prompts appear')
    then('all content is returned to mechanic')
      sothat('human attention stays on the actual work')
```

## usecase.2 = content blocked at border

```
given('fetched content contains security risk')
  when('mechanic fetches the url')
    then('mechanic receives "content blocked at border" message')
    then('mechanic does NOT receive the actual content')
      sothat('malicious content never reaches the agent')
    then('human is notified of the block')
    then('content is quarantined to .quarantine/ directory')
      sothat('human can inspect later')

given('fetched content is ambiguous or uncertain')
  when('border inspection cannot determine safety')
    then('content is blocked (deny entry by default)')
      sothat('security fails closed, not open')
    then('block reason is logged')
```

## usecase.3 = human inspects quarantined content

```
given('content was quarantined')
  when('human navigates to .quarantine/ directory')
    then('quarantined content is readable by human')
    then('block reason is visible alongside content')
      sothat('human understands why it was stopped')

given('quarantined content was a false positive')
  when('human reviews and determines content is safe')
    then('human can release content manually')
      sothat('legitimate research is not permanently blocked')
```

## usecase.4 = edge cases at the border

```
given('border inspection times out')
  when('mechanic fetches a url')
    then('content is blocked')
    then('mechanic receives "fetch timed out at border inspection"')
      sothat('timeout doesn't silently pass content through')

given('border inspection errors')
  when('mechanic fetches a url')
    then('content is blocked')
    then('mechanic receives "border inspection failed; entry denied"')
      sothat('errors fail closed')

given('fetched content is very large (exceeds review limit)')
  when('mechanic fetches a url')
    then('content is blocked')
    then('mechanic receives "content too large for inspection"')
      sothat('large content cannot bypass inspection')

given('fetched content is binary (image, pdf, etc)')
  when('mechanic fetches a url')
    then('content is blocked')
    then('mechanic receives "binary content cannot be inspected"')
      sothat('uninspectable content is denied entry')

given('url points to localhost')
  when('mechanic attempts to fetch')
    then('fetch is blocked')
    then('mechanic receives "localhost urls denied at border"')
      sothat('local resources are protected')

given('url points to private ip range (10.x, 172.16.x, 192.168.x)')
  when('mechanic attempts to fetch')
    then('fetch is blocked')
    then('mechanic receives "private network urls denied at border"')
      sothat('internal network is protected')
```

## usecase.5 = trusted domain allowlist

```
given('url matches a trusted domain pattern (e.g., github.com/ehmpathy/*)')
  when('mechanic fetches the url')
    then('content bypasses border guard inspection')
    then('content is returned directly to mechanic')
      sothat('trusted sources have zero latency overhead')

given('url does NOT match any trusted domain pattern')
  when('mechanic fetches the url')
    then('content goes through border guard inspection')
      sothat('untrusted sources are inspected')
```

## usecase.6 = latency experience

```
given('network fetch takes ~200ms')
  when('border inspection adds up to ~3s review time')
    then('total latency is up to ~3.2s')
      sothat('latency is acceptable for research tasks')
```

## usecase.6 = mechanic cannot access quarantine

```
given('content is quarantined in .quarantine/')
  when('mechanic attempts to read quarantined content')
    then('read is denied')
    then('mechanic receives "quarantined content is not accessible"')
      sothat('blocked content cannot be accessed via alternate path')
```
