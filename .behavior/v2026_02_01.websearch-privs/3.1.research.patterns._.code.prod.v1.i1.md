# research: prod code patterns for websearch.border.guard

## pattern.1 = PreToolUse hooks

[EXTEND]

### what

shell scripts that intercept tool calls before execution, with allow/block decision logic.

### current implementation

located at `src/domain.roles/mechanic/inits/claude.hooks/pretooluse.*.sh`

```bash
# from pretooluse.check-permissions.sh [1]
set -euo pipefail

# Read JSON from stdin (Claude Code passes input via stdin, not env var)
STDIN_INPUT=$(cat)

# failfast: if no input received, something is wrong
if [[ -z "$STDIN_INPUT" ]]; then
  echo "ERROR: PreToolUse hook received no input via stdin" >&2
  exit 2  # exit 2 = blocking error per Claude Code docs
fi

# Extract command from stdin JSON
COMMAND=$(echo "$STDIN_INPUT" | jq -r '.tool_input.command // empty' 2>/dev/null || echo "")
```

### exit code semantics

```bash
# from pretooluse.check-permissions.sh [1]
exit 0   # allow the operation
exit 2   # exit 2 = block with error message
```

### HARDNUDGE pattern

blocks on first attempt, allows on retry within time window:

```bash
# from pretooluse.check-permissions.sh [1]
HARDNUDGE_WINDOW_SECONDS=60  # default: 60 seconds

# Check if this command was recently attempted
now=$(date +%s)
last_attempt=$(jq -r --arg cmd "$COMMAND" '.[$cmd] // 0' "$ATTEMPTED_FILE" 2>/dev/null || echo "0")
elapsed=$((now - last_attempt))

if [[ $elapsed -lt $HARDNUDGE_WINDOW_SECONDS ]]; then
  # Claude already tried within the window - they've thought twice
  exit 0
fi
```

### relation to wish

PreToolUse hooks currently gate BEFORE tool execution. the border guard needs PostToolUse hooks to inspect AFTER fetch completes but before content reaches agent.

### decision

EXTEND — add PostToolUse hooks for WebFetch and WebSearch that invoke border guard inspection.

---

## pattern.2 = permissions configuration

[REUSE]

### what

declarative allowlist/denylist in `.claude/settings.json` for auto-approval decisions.

### current implementation

located at `src/domain.roles/mechanic/inits/init.claude.permissions.jsonc`

```jsonc
// from init.claude.permissions.jsonc [2]
{
  "permissions": {
    "deny": [
      "Bash(sed:*)",
      "Bash(mv:*)"
    ],
    "allow": [
      "WebSearch",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:www.npmjs.com)"
    ]
  }
}
```

### domain allowlist pattern

already exists for WebFetch:

```jsonc
// from init.claude.permissions.jsonc [2]
"WebFetch(domain:github.com)",
"WebFetch(domain:raw.githubusercontent.com)",
```

### quarantine access denial

permissions denylist can block agent reads:

```jsonc
// pattern from init.claude.permissions.jsonc [2]
"deny": [
  "Read(.quarantine/*)"
]
```

### relation to wish

the permissions allowlist already supports WebSearch and domain-scoped WebFetch. quarantine access can be denied via denylist.

### decision

REUSE — extend allowlist with additional trusted domains; add quarantine denylist.

---

## pattern.3 = skills structure

[EXTEND]

### what

shell scripts with structured headers, named args, and rhachet integration.

### current implementation

located at `src/domain.roles/mechanic/skills/`

```bash
# from sedreplace.sh [3]
#!/usr/bin/env bash
######################################################################
# .what = safe find-and-replace across git-tracked files only
#
# .why  = enables bulk text replacement without:
#         - touching files outside the repo
#         - modifying untracked files
#
# usage:
#   sedreplace.sh --old "pattern" --new "replacement"
#
# guarantee:
#   - only operates on git-tracked files (git ls-files)
#   - preview by default, --execute to apply
#   - fail-fast on errors
######################################################################
set -euo pipefail

# parse named arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --old)
      OLD_PATTERN="$2"
      shift 2
      ;;
    --repo|--role|--skill)
      # rhachet passthrough args - ignore
      shift 2
      ;;
  esac
done
```

### relation to wish

border guard could be implemented as a skill invoked by PostToolUse hook.

### decision

EXTEND — create borderGuard skill that PostToolUse hook invokes.

---

## pattern.4 = hook registration via Role.build()

[EXTEND]

### what

hooks registered via `Role.build()` in the role definition file, with `onTool` filter for tool-specific hooks.

### current implementation

located at `src/domain.roles/mechanic/getMechanicRole.ts`

```ts
// from getMechanicRole.ts [4]
export const ROLE_MECHANIC: Role = Role.build({
  slug: 'mechanic',
  hooks: {
    onBrain: {
      onBoot: [
        {
          command: './node_modules/.bin/rhachet roles boot --repo ehmpathy --role mechanic',
          timeout: 'PT60S',
        },
      ],
      onTool: [
        {
          command: './node_modules/.bin/rhachet run --repo ehmpathy --role mechanic --init claude.hooks/pretooluse.check-permissions',
          timeout: 'PT5S',
          filter: { what: 'Bash', when: 'before' },
        },
      ],
    },
  },
});
```

### filter structure

```ts
// from getMechanicRole.ts [4]
filter: { what: 'Write|Edit', when: 'before' }  // PreToolUse
filter: { what: 'WebFetch', when: 'after' }     // PostToolUse (pattern for border guard)
```

### relation to wish

add `onTool` entries with `when: 'after'` for WebFetch and WebSearch to invoke border guard.

### decision

EXTEND — add PostToolUse hook registration with `filter: { what: 'WebFetch|WebSearch', when: 'after' }`.

---

## summary

| pattern | decision | rationale |
|---------|----------|-----------|
| PreToolUse hooks | EXTEND | add PostToolUse variant for content inspection |
| permissions config | REUSE | extend allowlist; add quarantine denylist |
| skills structure | EXTEND | create borderGuard skill |
| hook registration | EXTEND | add onTool with `when: 'after'` filter |

---

## citations

[1] src/domain.roles/mechanic/inits/claude.hooks/pretooluse.check-permissions.sh
[2] src/domain.roles/mechanic/inits/init.claude.permissions.jsonc
[3] src/domain.roles/mechanic/skills/claude.tools/sedreplace.sh
[4] src/domain.roles/mechanic/getMechanicRole.ts
