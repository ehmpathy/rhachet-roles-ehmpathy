# blueprint: proactive forbidden term enforcement

## .summary

implement a configurable term blocklist hook that proactively forbids terms via the HARDNUDGE pattern, following the established `pretooluse.forbid-gerunds.sh` pattern.

---

## .scope

### deliverables

1. **rename gerunds hook** for naming consistency
   - `pretooluse.forbid-gerunds.sh` â†’ `pretooluse.forbid-terms.gerunds.sh`
   - `gerunds.allowlist.jsonc` â†’ `terms.gerunds.allowlist.jsonc`
   - update all references

2. **new blocklist config file**
   - `terms.blocklist.jsonc` â€” configurable list of forbidden terms

3. **new blocklist hook**
   - `pretooluse.forbid-terms.blocklist.sh` â€” reads config, enforces blocklist

4. **hook registration**
   - update `init.claude.hooks.sh` to register both hooks

5. **test coverage**
   - unit tests for blocklist hook (`.test.sh`)
   - integration tests for hook behavior

---

## .domain objects

### ForbiddenTerm

```ts
interface ForbiddenTerm {
  /**
   * the term to forbid (case-insensitive match)
   */
  term: string;

  /**
   * why this term is forbidden
   */
  why: string;

  /**
   * alternative terms to suggest
   */
  alt: string[];
}
```

### TermBlocklistConfig

```jsonc
// terms.blocklist.jsonc
{
  "terms": [
    {
      "term": "script",
      "why": "overloaded and vague â€” conflates command, procedure, operation, and mechanism",
      "alt": ["command", "executable", "procedure", "operation", "mechanism"]
    }
  ]
}
```

---

## .file structure

```
src/domain.roles/mechanic/inits/claude.hooks/
â”œâ”€â”€ pretooluse.forbid-terms.gerunds.sh        # renamed from pretooluse.forbid-gerunds.sh
â”œâ”€â”€ pretooluse.forbid-terms.gerunds.test.sh   # renamed from pretooluse.forbid-gerunds.test.sh
â”œâ”€â”€ terms.gerunds.allowlist.jsonc             # renamed from gerunds.allowlist.jsonc
â”œâ”€â”€ pretooluse.forbid-terms.blocklist.sh      # NEW: blocklist enforcement hook
â”œâ”€â”€ pretooluse.forbid-terms.blocklist.test.sh # NEW: blocklist hook tests
â””â”€â”€ terms.blocklist.jsonc                     # NEW: blocklist configuration
```

---

## .implementation steps

### phase 1: rename gerunds hook (consistency)

#### step 1.1: rename files

| from | to |
|------|-----|
| `pretooluse.forbid-gerunds.sh` | `pretooluse.forbid-terms.gerunds.sh` |
| `pretooluse.forbid-gerunds.test.sh` | `pretooluse.forbid-terms.gerunds.test.sh` |
| `gerunds.allowlist.jsonc` | `terms.gerunds.allowlist.jsonc` |

#### step 1.2: update internal references

- update `ALLOWLIST_FILE` path in gerunds hook
- update `HOOK_SCRIPT` path in gerunds test
- update `NUDGE_FILE` name to `terms.gerunds.nudges.local.json`

#### step 1.3: update hook registration

- update `init.claude.hooks.sh` to reference new filename

### phase 2: create blocklist config

#### step 2.1: create terms.blocklist.jsonc

```jsonc
{
  // forbidden terms blocklist
  // each entry specifies a term to forbid with rationale and alternatives
  "terms": [
    {
      "term": "script",
      "why": "overloaded and vague â€” conflates command, procedure, operation, and mechanism",
      "alt": ["command", "executable", "procedure", "operation", "mechanism"]
    }
  ]
}
```

### phase 3: implement blocklist hook

#### step 3.1: create pretooluse.forbid-terms.blocklist.sh

**header documentation:**
```bash
#!/usr/bin/env bash
######################################################################
# .what = PreToolUse hook to forbid terms from a configurable blocklist
#
# .why  = certain terms are overloaded or vague and degrade precision.
#         this hook blocks Write and Edit operations that contain
#         blocklisted terms, via the HARDNUDGE pattern (block first,
#         allow retry).
#
# .how  = reads JSON from stdin, extracts content from Write/Edit,
#         loads terms.blocklist.jsonc, scans for matches, blocks
#         on first attempt but allows retry within 5 minutes.
#
# usage:
#   configure in .claude/settings.json under hooks.PreToolUse
#
# guarantee:
#   âœ” blocks blocklisted terms on first attempt
#   âœ” allows retry within 5 min window (HARDNUDGE)
#   âœ” shows why term is forbidden and alternatives
######################################################################
```

**core logic:**

1. read JSON from stdin
2. extract tool name, skip if not Write/Edit
3. extract content to scan (Write: content, Edit: new_string)
4. load `terms.blocklist.jsonc` config
5. scan content for each blocklisted term (case-insensitive word boundary match)
6. for each match:
   - check HARDNUDGE window (5 min)
   - if within window: allow
   - if outside window: record attempt, add to blocked list
7. if any terms blocked:
   - output block message with term, why, and alternatives
   - exit 2
8. else: exit 0

**key implementation details:**

```bash
# load blocklist config
BLOCKLIST_FILE="$SCRIPT_DIR/terms.blocklist.jsonc"

# parse blocklist (strip comments, extract terms array)
TERMS_JSON=$(sed 's|//.*||' "$BLOCKLIST_FILE" | jq -c '.terms // []')

# scan for each term with word boundaries
for row in $(echo "$TERMS_JSON" | jq -c '.[]'); do
  TERM=$(echo "$row" | jq -r '.term')
  WHY=$(echo "$row" | jq -r '.why')
  ALT=$(echo "$row" | jq -r '.alt | join(", ")')

  # case-insensitive word boundary match
  if echo "$CONTENT" | grep -iqE "\\b${TERM}\\b"; then
    # check HARDNUDGE, block if outside window
  fi
done
```

**block message format:**

```
ðŸ›‘ BLOCKED: forbidden term(s) detected in file write

file: path/to/file.ts

detected terms:
  â›” script
    why: overloaded and vague â€” conflates command, procedure, operation, and mechanism
    alt: command, executable, procedure, operation, mechanism

see rule.forbid.term-* briefs for rationale.

if this is intentional and absolutely unavoidable, retry the same operation.
```

### phase 4: hook registration

#### step 4.1: update init.claude.hooks.sh

add registration for blocklist hook:

```bash
# forbid-terms.blocklist hook
"$INITS_DIR/init.claude.hooks.findsert.sh" \
  --hook-type PreToolUse \
  --matcher "Write" \
  --command "bash $HOOKS_DIR/pretooluse.forbid-terms.blocklist.sh" \
  --name "forbid-terms.blocklist (Write)" \
  --timeout 5

"$INITS_DIR/init.claude.hooks.findsert.sh" \
  --hook-type PreToolUse \
  --matcher "Edit" \
  --command "bash $HOOKS_DIR/pretooluse.forbid-terms.blocklist.sh" \
  --name "forbid-terms.blocklist (Edit)" \
  --timeout 5
```

### phase 5: test coverage

#### step 5.1: create pretooluse.forbid-terms.blocklist.test.sh

**test cases:**

| case | given | when | then |
|------|-------|------|------|
| [case1] | Write with blocklisted term "script" | first attempt | blocks with exit 2, shows term + why + alt |
| [case2] | Write with blocklisted term "script" | retry within 5 min | allows with exit 0 |
| [case3] | Write without blocklisted terms | any attempt | allows with exit 0 |
| [case4] | Edit with blocklisted term in new_string | first attempt | blocks with exit 2 |
| [case5] | Edit with blocklisted term only in old_string | any attempt | allows (only scans additions) |
| [case6] | Bash tool call with blocklisted term | any attempt | allows (not Write/Edit) |
| [case7] | Write with term as substring (e.g., "typescript") | any attempt | allows (word boundary) |
| [case8] | Write with term in different case (e.g., "SCRIPT") | first attempt | blocks (case-insensitive) |
| [case9] | empty blocklist config | any attempt | allows (no terms to check) |
| [case10] | empty stdin | any attempt | errors with exit 2 |

**test structure:**

```bash
#!/usr/bin/env bash
######################################################################
# .what = tests for pretooluse.forbid-terms.blocklist.sh hook
#
# .why  = verify the hook correctly blocks terms from blocklist config
#         and respects HARDNUDGE retry window
#
# .how  = runs the hook with various stdin JSON inputs and checks
#         exit codes and output
######################################################################

set -euo pipefail

# ... test implementation following gerunds test pattern ...
```

---

## .test coverage matrix

### unit tests (hook logic)

| component | test file | coverage |
|-----------|-----------|----------|
| blocklist hook | `pretooluse.forbid-terms.blocklist.test.sh` | term detection, HARDNUDGE, word boundaries, case sensitivity |
| gerunds hook | `pretooluse.forbid-terms.gerunds.test.sh` | existing tests, path updates |

### integration tests (hook <-> settings)

| flow | verification |
|------|--------------|
| hook registration | `init.claude.hooks.sh` registers both hooks |
| config loading | hooks load their respective config files |
| HARDNUDGE state | nudge files created/read correctly |

### acceptance tests (end-to-end blackbox)

| scenario | verification |
|----------|--------------|
| Write with "script" | blocked on first attempt, allowed on retry |
| Edit with blocklisted term | blocked appropriately |
| term in code vs prose | both detected |

---

## .nudge file strategy

each hook maintains its own nudge file:
- `terms.gerunds.nudges.local.json` â€” gerunds HARDNUDGE state
- `terms.blocklist.nudges.local.json` â€” blocklist HARDNUDGE state

key format: `sha256(file_path:term)`

---

## .dependencies

- `jq` â€” JSON parsing
- `bash` â€” shell execution
- `grep` â€” pattern matching
- `sha256sum` â€” nudge key generation

---

## .risks and mitigations

| risk | mitigation |
|------|------------|
| false positives (e.g., "typescript" matches "script") | word boundary matching (`\b`) |
| config file missing | fail gracefully, allow operation |
| jq not installed | check dependency, clear error message |
| rename breaks existing nudge state | nudge file migration or fresh start (acceptable, 5 min window) |

---

## .out of scope

- GUI for managing blocklist (manual config edit)
- automatic term suggestion via AI
- multi-repo blocklist inheritance

---

## .acceptance criteria

1. âœ… `pretooluse.forbid-gerunds.sh` renamed to `pretooluse.forbid-terms.gerunds.sh`
2. âœ… `terms.blocklist.jsonc` contains initial "script" entry with why and alt
3. âœ… `pretooluse.forbid-terms.blocklist.sh` blocks terms from config
4. âœ… HARDNUDGE pattern: blocks first attempt, allows retry within 5 min
5. âœ… word boundary matching prevents false positives
6. âœ… case-insensitive matching
7. âœ… block message shows term, why, and alternatives
8. âœ… all tests pass
9. âœ… hooks registered via `init.claude.hooks.sh`
