# blackbox criteria: kernelize skill

## usecase.1 = single extraction

```
given('a brief with semantic content')
  when('kernelize is invoked without --consensus')
    then('returns kernel list with id, concept, category for each')
      sothat('user can see distinct concepts in the brief')
    then('returns kernelCount equal to length of kernels array')
    then('returns rationale for extraction decisions')
    then('completes within 60 seconds')

  when('kernelize is invoked with --into path')
    then('writes json output to specified path')
    then('returns same structure as stdout mode')

given('an empty brief')
  when('kernelize is invoked')
    then('returns empty kernels array')
    then('returns kernelCount of 0')
    then('returns rationale "empty content"')
```

## usecase.2 = consensus extraction

```
given('a brief with semantic content')
  when('kernelize is invoked with --consensus 3')
    then('runs 3 parallel extractions')
    then('returns only kernels that appear in majority of runs')
    then('returns consensus metadata with runs=3, threshold=0.5')
      sothat('user knows the consensus parameters used')

  when('kernelize is invoked with --consensus 5 --threshold 0.7')
    then('runs 5 parallel extractions')
    then('returns only kernels that appear in ≥70% of runs')
    then('returns consensus metadata with runs=5, threshold=0.7')

given('a brief where extractions diverge significantly')
  when('kernelize is invoked with --consensus 3 --threshold 0.9')
    then('returns fewer kernels than single extraction')
      sothat('only high-confidence kernels are retained')
```

## usecase.3 = output format

```
given('any valid brief')
  when('kernelize completes')
    then('output is valid json')
    then('output contains source field with input path')
    then('output contains kernelCount field as integer')
    then('output contains kernels array')
    then('each kernel has id, concept, category fields')
    then('category is one of: rule, principle, definition, pattern, constraint')
    then('output contains rationale field as string')

  when('--consensus was used')
    then('output contains consensus object')
    then('consensus contains runs and threshold fields')
```

## usecase.4 = error conditions

```
given('a nonexistent file path')
  when('kernelize is invoked')
    then('exits with error')
    then('error message indicates file not found')

given('a file that is not markdown')
  when('kernelize is invoked')
    then('proceeds with extraction')
      sothat('non-.md text files can still be processed')

given('brain service unavailable')
  when('kernelize is invoked')
    then('exits with error after timeout')
    then('error message indicates brain failure')
```

## usecase.5 = eval scenarios

```
given('a brief with known ground truth kernels')
  when('kernelize is invoked N times without consensus')
    then('jaccard similarity across runs is measurable')
      sothat('stability metric can be computed')

  when('kernelize is invoked with consensus')
    then('consensus result can be compared to ground truth')
      sothat('precision and recall can be computed')

given('eval matrix of N=[1,3,5,7] × T=[0.3,0.5,0.7,0.9]')
  when('kernelize is invoked for each configuration')
    then('stability metric is recorded per configuration')
    then('precision/recall vs ground truth is recorded')
    then('latency is recorded')
    then('token cost is recorded')
      sothat('optimal configuration can be identified')
```
