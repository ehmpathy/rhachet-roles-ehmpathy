# plan: kernel retention optimization

## problem statement

`sup:kernelize` pipelines should guarantee better kernel retention since they supply extracted kernels as context to compression. however, perfeval data shows inconsistent results:

| pipeline | kern.Δ | expected |
|----------|--------|----------|
| `sup:kernelize, [sitrep-taskaware]` | -0.9 | ✓ good |
| `sup:kernelize, [sitrep-aggressive]` | -6.2 | ✗ should be better |
| `sup:kernelize, [sitrep]` | -5.5 | ✗ should be better |

**root cause**: kernels are supplied as soft context ("use this to inform your compression"), not as a hard constraint ("you MUST preserve these concepts").

## findings from perfeval 2026-02-14.3

### high-retention pipelines (kern.Δ > -1)

| pipeline | dens.Δ | kern.Δ | tok.Δ |
|----------|--------|--------|-------|
| `[[sitrep, telegraphic]]` | +1.2 | **-0.2** | -615 |
| `[[telegraphic, sitrep]]` | +1.8 | **-0.4** | -930 |
| `sup:kernelize, [sitrep-taskaware]` | +2.5 | **-0.9** | -867 |

### by brief type

| doctype | dens.Δ | kern.Δ | retention |
|---------|--------|--------|-----------|
| lesson | +1.5 | -0.6 | ~95% |
| tactic | +4.2 | -1.7 | ~91% |
| concept | +5.5 | -2.5 | ~88% |
| rule | +2.5 | -4.3 | ~78% |
| reference | +2.1 | -7.0 | ~74% |

### key insight

`sitrep-taskaware` methodology respects kernels better than aggressive variants. a combination with proper kernel supply should yield optimal results.

---

## proposed fixes

### fix 1: hard constraint prompt for supply pipelines

current (soft):
```
SUPPLEMENT CONTEXT (use this to inform your compression):
---
- [rule] all procedures use (input, context) pattern
- [principle] dependency injection via context
---
```

proposed (hard):
```
CRITICAL CONSTRAINT: These concepts are REQUIRED in your output.
Any absent concept is a compression failure. Preserve the semantic sense even if you rephrase.

REQUIRED KERNELS (must appear in output):
- [rule] all procedures use (input, context) pattern
- [principle] dependency injection via context
```

### fix 2: kernel verification + retry loop

```ts
const compressed = await compress({ content, supplements: kernels });
const retention = await checkKernelRetention({ kernels, compressed });

if (retention.lost.length > 0 && retryCount < MAX_RETRIES) {
  // retry with explicit lost kernel restoration request
  return compress({
    content: compressed,
    supplements: [`RESTORE THESE LOST CONCEPTS: ${retention.lost.map(k => k.concept).join(', ')}`],
  });
}
```

### fix 3: kernel restoration post-pass

after final compression pass, append any lost kernels:
```ts
const lost = kernelsBefore.filter(k => !isKernelPresent(k, compressed));
if (lost.length > 0) {
  return compressed + '\n\n## core concepts\n' + lost.map(k => `- ${k.concept}`).join('\n');
}
```

---

## new pipeline combinations to test

### supply variants with hard constraint

| pipeline | hypothesis |
|----------|------------|
| `sup:kernelize-strict, [sitrep]` | hard constraint + gentle compression |
| `sup:kernelize-strict, [sitrep-taskaware]` | hard constraint + task-aware |
| `sup:kernelize-strict, [telegraphic]` | hard constraint + telegraphic |
| `sup:kernelize-strict, [sitrep], [telegraphic]` | hard + chained |
| `sup:kernelize-strict, [sitrep-taskaware], [telegraphic]` | hard + task-aware + telegraphic |

### gentle compression variants

| pipeline | hypothesis |
|----------|------------|
| `[[sitrep], [sitrep]]` | double gentle pass |
| `[[sitrep], [sitrep-taskaware]]` | gentle → task-aware |
| `[[sitrep-taskaware], [sitrep-taskaware]]` | double task-aware |
| `[[telegraphic], [telegraphic]]` | double telegraphic |
| `[[sitrep, sitrep-taskaware]]` | combined gentle |

### verification loop variants

| pipeline | hypothesis |
|----------|------------|
| `sup:kernelize, [sitrep], verify` | soft supply + verification |
| `sup:kernelize, [sitrep-taskaware], verify` | task-aware + verification |
| `sup:kernelize-strict, [sitrep], verify` | hard + verification |

### restoration variants

| pipeline | hypothesis |
|----------|------------|
| `sup:kernelize, [sitrep-aggressive], restore` | aggressive + restore lost |
| `sup:kernelize, [sitrep-aggro-aware], restore` | aggro-aware + restore |

---

## exhaustive test matrix

### base methodologies
- `sitrep`
- `sitrep-aggressive`
- `sitrep-taskaware`
- `sitrep-iterative`
- `sitrep-aggro-aware`
- `telegraphic`

### supply modes
- none (mutator pipeline)
- `sup:kernelize` (soft context)
- `sup:kernelize-strict` (hard constraint)

### chain lengths
- 1 pass: `[[M1]]`
- 2 pass: `[[M1], [M2]]` and `[[M1, M2]]`
- 3 pass: `[[M1], [M2], [M3]]`

### post-process modes
- none
- `verify` (check + retry if lost)
- `restore` (append lost kernels)

### full combination count

```
base methodologies: 6
supply modes: 3
chain patterns: ~15 (selected, not all permutations)
post-process modes: 3
briefs: 8
runs per pair: 3

estimated combinations: 6 × 3 × 15 × 3 = 810 pipeline configs
estimated total runs: 810 × 8 × 3 = 19,440 compressions
```

### prioritized subset for initial test

focus on high-retention candidates:

```ts
const PRIORITY_PIPELINES = [
  // proven high-retention
  { supply: null, press: [['sitrep', 'telegraphic']] },
  { supply: null, press: [['telegraphic', 'sitrep']] },
  { supply: 'kernelize', press: [['sitrep-taskaware']] },

  // new: hard constraint variants
  { supply: 'kernelize-strict', press: [['sitrep']] },
  { supply: 'kernelize-strict', press: [['sitrep-taskaware']] },
  { supply: 'kernelize-strict', press: [['telegraphic']] },
  { supply: 'kernelize-strict', press: [['sitrep'], ['telegraphic']] },
  { supply: 'kernelize-strict', press: [['sitrep-taskaware'], ['telegraphic']] },

  // new: gentle double-pass
  { supply: null, press: [['sitrep'], ['sitrep']] },
  { supply: null, press: [['sitrep'], ['sitrep-taskaware']] },
  { supply: null, press: [['sitrep-taskaware'], ['sitrep-taskaware']] },
  { supply: null, press: [['telegraphic'], ['telegraphic']] },

  // new: verification loop
  { supply: 'kernelize', press: [['sitrep']], verify: true },
  { supply: 'kernelize', press: [['sitrep-taskaware']], verify: true },
  { supply: 'kernelize-strict', press: [['sitrep']], verify: true },

  // new: restoration
  { supply: 'kernelize', press: [['sitrep-aggressive']], restore: true },
  { supply: 'kernelize', press: [['sitrep-aggro-aware']], restore: true },
];
```

---

## implementation phases

### phase 1: implement hard constraint supply mode

1. add `kernelize-strict` supply mode to `compress.via.bhrain.ts`
2. modify `genCompressionPrompt` to emit hard constraint when supply is strict
3. add integration test for strict mode

### phase 2: implement verification loop

1. add `verify` post-process option to pipeline config
2. implement `verifyAndRetry` function that checks retention and retries
3. add integration test for verification loop

### phase 3: implement kernel restoration

1. add `restore` post-process option to pipeline config
2. implement `restoreLostKernels` function that appends lost concepts
3. add integration test for restoration

### phase 4: run exhaustive perfeval

1. add new pipeline configs to `PIPELINES` array
2. run full perfeval with prioritized subset
3. analyze results for optimal configuration

### phase 5: document findings

1. emit perfeval report to `.perfevals/`
2. update methodology briefs with findings
3. recommend default pipeline for production use

---

## success criteria

1. **retention target**: kern.Δ > -1 (less than 1 kernel lost on average)
2. **density target**: dens.Δ > +2 (meaningful compression benefit)
3. **consistency**: kern.σ < 1 (low variance across runs)
4. **coverage**: works across all brief types (rule, lesson, concept, reference, tactic)

## expected outcome

identify optimal pipeline that achieves:
- ~95%+ kernel retention (kern.Δ > -1)
- ~2x+ density increase (dens.Δ > +2)
- consistent across brief types
- reasonable latency (<30s per compression)

candidate hypothesis: `sup:kernelize-strict, [sitrep-taskaware]` or `sup:kernelize, [sitrep-taskaware], verify`
