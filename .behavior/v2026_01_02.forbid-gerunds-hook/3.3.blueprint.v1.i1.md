# blueprint: forbid-gerunds-hook

## overview

add a PreToolUse hook to the mechanic role that blocks file writes and edits that contain gerunds (-ing words), via the HARDNUDGE pattern.

## architecture

```
src/domain.roles/mechanic/
â”œâ”€â”€ inits/
â”‚   â”œâ”€â”€ claude.hooks/
â”‚   â”‚   â”œâ”€â”€ pretooluse.forbid-gerunds.sh          # [NEW] main hook script
â”‚   â”‚   â”œâ”€â”€ pretooluse.forbid-gerunds.test.sh     # [NEW] tests for the hook
â”‚   â”‚   â””â”€â”€ gerunds.allowlist.jsonc               # [NEW] allowlist of acceptable -ing words
â”‚   â””â”€â”€ init.claude.hooks.sh                      # [MODIFY] register new hook
```

## components

### 1. pretooluse.forbid-gerunds.sh

**purpose**: intercept Write and Edit tool calls, scan for gerunds, block with HARDNUDGE

**input** (stdin JSON from claude code per [hooks reference](https://code.claude.com/docs/en/hooks)):
```json
{
  "session_id": "abc123",
  "transcript_path": "/path/to/transcript.jsonl",
  "cwd": "/path/to/project",
  "permission_mode": "default",
  "hook_event_name": "PreToolUse",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/path/to/file.ts",
    "content": "const existingUser = ..."
  },
  "tool_use_id": "toolu_01ABC123..."
}
```
or for Edit:
```json
{
  "hook_event_name": "PreToolUse",
  "tool_name": "Edit",
  "tool_input": {
    "file_path": "/path/to/file.ts",
    "old_string": "...",
    "new_string": "const processingQueue = ..."
  }
}
```

**algorithm**:
```
1. read JSON from stdin
2. extract tool_name and tool_input
3. if tool_name not in [Write, Edit] â†’ exit 0 (allow)
4. extract content to scan:
   - Write: tool_input.content
   - Edit: tool_input.new_string (only scan additions)
5. extract all -ing words via regex: \b\w+ing\b
6. filter against allowlist â†’ gerunds_detected
7. if gerunds_detected is empty â†’ exit 0 (allow)
8. for each gerund in gerunds_detected:
   a. build nudge_key = hash(file_path + gerund)
   b. check .claude/gerund.nudges.local.json for prior attempt
   c. if prior attempt within 5 min â†’ allow this gerund (continue)
   d. else â†’ record attempt, add to blocked list
9. if blocked list is empty â†’ exit 0 (allow)
10. output block message with:
    - list of detected gerunds
    - suggested alternatives
    - instruction to retry if intentional
11. exit 2 (block)
```

**exit codes**:
- 0 = allow
- 2 = block (per claude code docs)

**nudge track file**: `.claude/gerund.nudges.local.json`
```json
{
  "hash1": 1735776000,
  "hash2": 1735775900
}
```

### 2. gerunds.allowlist.jsonc

**purpose**: list of -ing words that are not gerunds (acceptable), with comments explaining why

**content**:
```jsonc
{
  // unfortunately embedded in language primitives; they could have chosen better terms but did not
  "primitives": [
    "string"       // js/ts primitive type â€” stuck with it
  ]
}
```

**parse**: strip comments with `sed 's|//.*||'` before `jq`

**note**: start minimal, expand only when legitimate technical terms cause false positives

### 3. pretooluse.forbid-gerunds.test.sh

**purpose**: verify hook behavior

**test cases**:
```
given: Write with gerund "existingUser"
  when: first attempt
    then: blocked with exit 2
  when: retry within 5 min
    then: allowed with exit 0

given: Write with allowlisted word "string"
  when: content contains "const myString: string = 'hello'"
    then: allowed with exit 0 (string is in allowlist)

given: Write with gerund-as-noun like "building"
  when: content contains "const building = new Building()"
    then: blocked with exit 2 (no exceptions for noun forms)

given: Edit with gerund in new_string
  when: new_string contains "processingQueue"
    then: blocked with exit 2

given: Edit with gerund only in old_string
  when: old_string contains "loadingState", new_string is clean
    then: allowed with exit 0 (only scan additions)

given: Write without any -ing words
  when: content is clean
    then: allowed with exit 0

given: Bash tool call
  when: any command
    then: allowed with exit 0 (not our concern)

given: multiple gerunds in one write
  when: content has "existingUser" and "loadingState"
    then: blocked, message lists both gerunds
```

### 4. init.claude.hooks.sh modifications

**add new hook registration** (after forbid-stderr-redirect, before check-permissions):

```bash
run_findsert "pretooluse.forbid-gerunds" \
  --hook-type PreToolUse \
  --matcher "Write" \
  --command "$RHACHET_CLI roles init --repo ehmpathy --role mechanic --command claude.hooks/pretooluse.forbid-gerunds" \
  --name "pretooluse.forbid-gerunds.write" \
  --timeout 5

run_findsert "pretooluse.forbid-gerunds" \
  --hook-type PreToolUse \
  --matcher "Edit" \
  --command "$RHACHET_CLI roles init --repo ehmpathy --role mechanic --command claude.hooks/pretooluse.forbid-gerunds" \
  --name "pretooluse.forbid-gerunds.edit" \
  --timeout 5
```

## block message format

```
ðŸ›‘ BLOCKED: gerund(s) detected in file write

file: /path/to/file.ts

detected gerunds:
  â›” existingUser â†’ consider: userFound, userPrior, userCurrent
  â›” loadingState â†’ consider: loadState, stateLoaded, status

gerunds degrade clarity. see rule.forbid.gerunds for alternatives.

if this is intentional and absolutely unavoidable (e.g., library API requirement), retry the same operation.
```

## hardnudge time window

- window: 300 seconds (5 minutes)
- key: sha256(file_path + gerund_word)
- storage: `.claude/gerund.nudges.local.json`
- cleanup: prune entries older than 1 hour on each run

## edge cases

1. **binary files**: skip scan if file_path matches common binary extensions
2. **very large content**: scan first 100KB only to avoid timeout
3. **unicode**: use POSIX-compatible regex, focus on ASCII -ing words
4. **no .claude dir**: create it if absent
5. **malformed JSON**: exit 0 (allow) with warn message to stderr

## dependencies

- `jq` to parse JSON (already used by other hooks)
- `sha256sum` for nudge key generation
- standard bash utilities

## rollout

1. implement hook script
2. write tests
3. run tests locally
4. add to init.claude.hooks.sh
5. rebuild dist/
6. test in real session
