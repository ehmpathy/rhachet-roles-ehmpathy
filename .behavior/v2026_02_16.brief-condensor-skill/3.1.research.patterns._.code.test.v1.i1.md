# research patterns: test codepath

## isolated test environment

### [REUSE] genTempDir with git init

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.contract.integration.test.ts`

```ts
const runInTempGitRepo = (args: {
  files: Record<string, string>;
  compressArgs: string[];
}): { stdout: string; stderr: string; exitCode: number; tempDir: string } => {
  const tempDir = genTempDir({
    slug: 'bhrain-compress-test',
    git: true,
    clone: fixtureDir,
    symlink: [{ at: 'node_modules', to: 'node_modules' }],
  });
  // ...
};
```

**what**: creates isolated temp directory with git repo for each test

**pattern**:
- `git: true` initializes git repo
- `clone: fixtureDir` copies fixture files
- `symlink` links node_modules to avoid reinstall
- returns `tempDir` for cleanup or inspection

**relevance**: condense tests need isolated git repos for file operations

---

### [REUSE] sanitizeOutput for snapshot stability

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.contract.integration.test.ts`

```ts
const sanitizeOutput = (output: string): string =>
  output
    .replace(/\/tmp\/[a-zA-Z0-9_-]+/g, '/tmp/TEMP_DIR')
    .replace(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/g, 'TIMESTAMP')
    .replace(/tokens: \d+ → \d+/g, 'tokens: N → M');
```

**what**: replaces dynamic values with stable placeholders

**pattern**:
- temp paths → `/tmp/TEMP_DIR`
- timestamps → `TIMESTAMP`
- token counts → `N → M`

**relevance**: condense output includes temp paths, timestamps, token counts

---

## bdd test structure

### [REUSE] given/when/then with case labels

**location**: multiple test files

```ts
describe('compressViaBhrain', () => {
  given('[case1] valid markdown brief', () => {
    const scene = useBeforeAll(async () => {
      const brief = await loadBrief('rule.md');
      return { brief };
    });

    when('[t0] compress is invoked', () => {
      const result = useThen('it succeeds', async () =>
        compressViaBhrain({ content: scene.brief }, context),
      );

      then('it returns compressed content', () => {
        expect(result.compressed.length).toBeLessThan(scene.brief.length);
      });

      then('it returns token counts', () => {
        expect(result.tokens.before).toBeGreaterThan(0);
        expect(result.tokens.after).toBeGreaterThan(0);
      });
    });
  });
});
```

**what**: bdd structure with `[caseN]` and `[tN]` labels

**pattern**:
- `given('[caseN]` for scenarios
- `when('[tN]` for time/event steps
- `then` for assertions
- `useBeforeAll` for shared setup
- `useThen` for expensive operation result share

**relevance**: condense tests follow same bdd structure

---

### [REUSE] useThen for expensive brain calls

**location**: `src/domain.roles/mechanic/skills/brief.compress/extractKernels.integration.test.ts`

```ts
when('[t0] extractKernels is called', () => {
  const result = useThen('it succeeds', async () =>
    extractKernels({ content: scene.document }, context),
  );

  then('it returns kernels array', () => {
    expect(result.kernels).toBeInstanceOf(Array);
  });

  then('it returns forethought', () => {
    expect(result.forethought).toBeDefined();
  });

  then('it returns rationale', () => {
    expect(result.rationale).toBeDefined();
  });
});
```

**what**: share single brain call result across multiple assertions

**pattern**:
- `useThen` calls expensive operation once
- result proxy used in sibling `then` blocks
- avoids N× brain calls for N assertions

**relevance**: condense tests involve multiple brain calls; `useThen` reduces cost

---

## test fixtures

### [REUSE] test brief fixtures

**location**: `src/domain.roles/mechanic/skills/brief.compress/.test/fixtures/briefs.ts`

```ts
export interface TestBrief {
  name: string;
  type: 'rule' | 'concept' | 'lesson' | 'tactic' | 'reference' | 'define' | 'demo' | 'seed';
  filename: string;
  expectedKeyTerms: string[];
}

export const TEST_BRIEF_METADATA: TestBrief[] = [
  { name: 'input-context-pattern', type: 'rule', filename: 'input-context-pattern.md', expectedKeyTerms: ['input', 'context', 'pattern'] },
  { name: 'dependency-injection', type: 'concept', filename: 'dependency-injection.md', expectedKeyTerms: ['dependency', 'injection', 'context'] },
  { name: 'bdd-test', type: 'lesson', filename: 'bdd-test.md', expectedKeyTerms: ['given', 'when', 'then', 'test'] },
  // ... 8 total briefs
];

export const loadTestBrief = async (name: string): Promise<string> => {
  const brief = TEST_BRIEF_METADATA.find((b) => b.name === name);
  if (!brief) throw new Error(`brief not found: ${name}`);
  return fs.readFile(path.join(BRIEFS_DIR, brief.filename), 'utf-8');
};
```

**what**: 8 representative briefs with metadata and lazy load

**pattern**:
- metadata array with type, filename, expected key terms
- lazy load via `loadTestBrief(name)`
- covers rule, concept, lesson, tactic, reference types
- `expectedKeyTerms` for kernel extraction validation

**relevance**: condense tests reuse same fixtures for consistency

---

## perfeval infrastructure

### [REUSE] on-disk cache with withSimpleCachingAsync

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.perfeval.integration.test.ts`

```ts
import { createCache, withSimpleCachingAsync } from 'simple-on-disk-cache';

const CACHE_DIR = path.join(__dirname, '.perfevals/.cache');
const perfevalCache = createCache({ directory: { mounted: { path: CACHE_DIR } } });

const compressViaBhrainCached = withSimpleCachingAsync(
  async (input: { content: string; mechanism: MechanismOrModifier[] }) =>
    compressViaBhrain(input, context),
  {
    cache: perfevalCache,
    serialize: {
      key: ({ forInput }) => {
        const hash = toHashSha256Sync([forInput.content, forInput.mechanism.join(',')].join('::'));
        return `compress-${hash}`;
      },
    },
  },
);
```

**what**: cache brain call results to disk for perfeval runs

**pattern**:
- `createCache` with mounted directory
- `withSimpleCachingAsync` wraps async function
- cache key from content hash + mechanism
- enables re-runs without re-call of brain

**relevance**: condense perfevals need cache for variance measurement

---

### [REUSE] Bottleneck rate limiter

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.perfeval.integration.test.ts`

```ts
import Bottleneck from 'bottleneck';

const limiter = new Bottleneck({ maxConcurrent: 100 });

const results = await Promise.all(
  pipelines.map((pipeline) =>
    limiter.schedule(async () => {
      const result = await compressViaBhrainCached({ content, mechanism: pipeline });
      return { pipeline, result };
    }),
  ),
);
```

**what**: limit concurrent brain calls to avoid rate limits

**pattern**:
- `maxConcurrent: 100` for parallel requests
- `limiter.schedule()` queues work
- combined with `Promise.all` for batch execution

**relevance**: condense perfevals run N attempts × M briefs; rate limit needed

---

### [REUSE] progress log to jsonl

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.perfeval.integration.test.ts`

```ts
const logProgress = async (entry: PerfevalEntry) => {
  const line = JSON.stringify(entry) + '\n';
  await fs.appendFile(PROGRESS_FILE, line);
};

// in perfeval loop
await logProgress({
  brief: brief.name,
  pipeline: pipeline.name,
  attempt: i,
  densityDelta: result.densityDelta,
  kernelDelta: result.kernelDelta,
  timestamp: new Date().toISOString(),
});
```

**what**: append-only jsonl log for perfeval progress

**pattern**:
- one json object per line
- append to file (survives crashes)
- includes timestamp for correlation

**relevance**: condense perfevals need progress visibility

---

### [REUSE] perfeval report generation

**location**: `src/domain.roles/mechanic/skills/kernelize/kernelize.perfeval.ts`

```ts
const generateReport = (results: PerfevalResult[]): string => {
  const lines: string[] = [
    '# perfeval report',
    '',
    `generated: ${new Date().toISOString()}`,
    '',
    '## summary',
    '',
    `| brief | mean coverage | stability |`,
    `|-------|---------------|-----------|`,
  ];

  for (const result of results) {
    lines.push(`| ${result.brief} | ${result.meanCoverage.toFixed(2)} | ${result.stability.toFixed(2)} |`);
  }

  return lines.join('\n');
};
```

**what**: generate markdown report from perfeval results

**pattern**:
- markdown table format
- timestamp for report generation
- summary metrics per brief

**relevance**: condense perfevals need report output

---

## shell skill test

### [REUSE] spawnSync for skill execution

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.contract.integration.test.ts`

```ts
const result = spawnSync(
  'npx',
  ['rhachet', 'run', '--skill', 'brief.compress', ...compressArgs],
  {
    cwd: tempDir,
    encoding: 'utf-8',
    env: { ...process.env, FORCE_COLOR: '0' },
  },
);

return {
  stdout: result.stdout,
  stderr: result.stderr,
  exitCode: result.status ?? 1,
  tempDir,
};
```

**what**: execute shell skill via spawnSync

**pattern**:
- `cwd: tempDir` for isolated execution
- `FORCE_COLOR: '0'` disables ansi for stable output
- capture stdout, stderr, exitCode
- return all for assertions

**relevance**: condense skill invoked same way via spawnSync

---

### [REUSE] exit code assertions

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.contract.integration.test.ts`

```ts
then('exit code is 0', () => {
  expect(result.exitCode).toEqual(0);
});

then('exit code is 1 for error', () => {
  expect(result.exitCode).toEqual(1);
});

then('exit code is 2 for unstable', () => {
  expect(result.exitCode).toEqual(2);
});
```

**what**: assert exit codes match contract

**pattern**:
- 0 = success
- 1 = generic error
- 2 = kernelization unstable

**relevance**: condense skill has same exit code contract

---

## snapshot test

### [REUSE] toMatchSnapshot with sanitization

**location**: `src/domain.roles/mechanic/skills/brief.compress/compress.via.bhrain.contract.integration.test.ts`

```ts
then('output matches snapshot', () => {
  expect(sanitizeOutput(result.stdout)).toMatchSnapshot();
});
```

**what**: snapshot test for output format

**pattern**:
- sanitize dynamic values first
- snapshot captures expected output format
- visual regression detection in pr review

**relevance**: condense output format needs snapshot tests

---

## summary

| pattern | status | rationale |
|---------|--------|-----------|
| `genTempDir` with git | [REUSE] | isolated test environment |
| `sanitizeOutput` | [REUSE] | stable snapshots |
| `given/when/then` bdd | [REUSE] | standard test structure |
| `useThen` for brain calls | [REUSE] | reduce expensive calls |
| test brief fixtures | [REUSE] | consistent test data |
| on-disk cache | [REUSE] | perfeval efficiency |
| Bottleneck limiter | [REUSE] | rate limit brain calls |
| progress log jsonl | [REUSE] | perfeval visibility |
| perfeval report gen | [REUSE] | markdown reports |
| spawnSync skill exec | [REUSE] | shell skill tests |
| exit code assertions | [REUSE] | contract tests |
| snapshot with sanitize | [REUSE] | output format tests |

---

## test architecture for condense

```
condense.integration.test.ts
├── [case1] valid brief
│   ├── [t0] with default pipeline
│   │   └── useThen → compress + metrics
│   └── [t1] with custom pipeline
│       └── useThen → compress + metrics
├── [case2] unstable brief
│   └── [t0] exit code 2
├── [case3] batch glob
│   └── [t0] multiple outputs
└── [case4] error cases
    ├── [t0] empty file
    ├── [t1] file not found
    └── [t2] invalid spec

condense.perfeval.integration.test.ts
├── uses Bottleneck limiter
├── uses on-disk cache
├── logs progress to jsonl
└── generates markdown report
```

**new code needed**:
- `condense.integration.test.ts` — contract tests
- `condense.perfeval.integration.test.ts` — variance measurement
- test fixtures for unstable briefs (for exit code 2 tests)
