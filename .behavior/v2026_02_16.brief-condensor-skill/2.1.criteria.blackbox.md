# blackbox criteria: condense skill

## usecase.1 = condense with default pipeline

given('a valid markdown brief')
  when('condense is invoked with only --from')
    then('output shows pipeline used: sup:[kernelize], [[req-kernels, sitrep-aggressive], [telegraphic]]')
      sothat('the default recommended pipeline is applied automatically')
    then('output shows dens.Δ, dens.σ, kern.Δ, kern.σ metrics')
      sothat('the human sees quality inline without separate validation')
    then('output shows tokens before → after')
      sothat('compression ratio is visible')
    then('exit code is 0')

  when('condense is invoked with --mode plan')
    then('output shows what would be emitted')
    then('no .min file is created')
      sothat('plan mode previews without side effects')

  when('condense is invoked with --mode apply')
    then('{from}.min file is created')
    then('source file is unchanged')
      sothat('original brief is preserved')

---

## usecase.2 = condense with custom pipeline

given('a valid markdown brief')
  when('condense is invoked with --onPress "[[req-kernels, sitrep-aggressive], [req-kernels, telegraphic]]"')
    then('output shows pipeline used matches the custom spec')
    then('compression uses the specified steps in order')
      sothat('the human can tune the pipeline per brief')

  when('condense is invoked with --onSupply null')
    then('kernelization is skipped')
    then('output shows no kern.Δ or kern.σ metrics')
      sothat('the human can bypass kernelization when not needed')

---

## usecase.3 = lossless compression

given('a valid markdown brief')
  when('condense is invoked with 3-step req-kernels pipeline')
    then('kern.Δ is 0.0')
    then('kern.σ is 0.0')
      sothat('zero kernel loss is achieved via kernel injection at each step')

---

## usecase.4 = max compression with restore

given('a valid markdown brief')
  when('condense is invoked with --onVerify restore')
    then('any lost kernels are restored from source')
    then('output shows ver:[restore] in pipeline')
      sothat('aggressive compression can recover lost concepts')

given('a brief where compression loses kernels')
  when('condense is invoked without --onVerify')
    then('output shows warning about kernel loss')
    then('compression proceeds')
    then('exit code is 0')
      sothat('the human is informed but not blocked')

  when('condense is invoked with --onVerify restore')
    then('lost kernels are appended to output')
    then('kern.Δ after restore is 0 or positive')
      sothat('no concepts are permanently lost')

---

## usecase.5 = batch condensation

given('a glob pattern that matches multiple briefs')
  when('condense is invoked with --from "briefs/**/*.md"')
    then('each file matched is processed')
    then('each file gets its own .min output')
    then('aggregate metrics are shown')
      sothat('batch processing works without manual iteration')

---

## usecase.6 = unstable brief detection

given('a brief that produces inconsistent kernels across runs')
  when('condense is invoked')
    then('output shows error: "kernelization unstable"')
    then('output shows stability.meanJaccard < 0.7')
    then('output shows stability.minJaccard')
    then('output shows suggestion to revise brief')
    then('exit code is 2')
    then('no .min file is created')
      sothat('ambiguous briefs fail fast before compression')

---

## usecase.7 = variance measurement

given('a valid markdown brief')
  when('condense is invoked with --attempts 3 (default)')
    then('compression runs 3 times')
    then('output shows σ (standard deviation) for dens and kern')
      sothat('stability is measured across multiple runs')

  when('condense is invoked with --attempts 5')
    then('compression runs 5 times')
    then('variance is computed from 5 samples')
      sothat('the human can increase precision when needed')

---

## edge.1 = empty brief

given('an empty markdown file')
  when('condense is invoked')
    then('output shows error: "empty content"')
    then('exit code is 1')
      sothat('empty input fails fast with clear message')

---

## edge.2 = brief with no extractable kernels

given('a markdown file with no semantic content (e.g., only whitespace or format markers)')
  when('condense is invoked')
    then('output shows error: "no kernels extracted"')
    then('exit code is 1')
      sothat('content-free briefs fail fast')

---

## edge.3 = invalid pipeline spec

given('a valid markdown brief')
  when('condense is invoked with malformed --onPress spec')
    then('output shows error with invalid spec highlighted')
    then('exit code is 1')
      sothat('syntax errors are caught immediately')

  when('condense is invoked with unknown brief name in --onPress')
    then('output shows error: "unknown brief: {name}"')
    then('exit code is 1')
      sothat('typos in brief names are caught')

---

## edge.4 = file not found

given('a path that does not exist')
  when('condense is invoked with --from nonexistent.md')
    then('output shows error: "file not found: nonexistent.md"')
    then('exit code is 1')

---

## edge.5 = glob matches no files

given('a glob pattern that matches no files')
  when('condense is invoked with --from "nofiles/**/*.md"')
    then('output shows error: "no files matched"')
    then('exit code is 1')

---

## edge.6 = output path conflict

given('a valid markdown brief')
  when('condense is invoked with --into pointing to extant file and --mode apply')
    then('extant file is overwritten')
      sothat('idempotent re-runs work without manual cleanup')

---

## edge.7 = brain provider error

given('a valid markdown brief')
  when('brain provider returns an error (rate limit, timeout, etc)')
    then('output shows error with provider details')
    then('exit code is 1')
      sothat('external failures surface clearly')

---

## contract.inputs

| arg | type | required | validation |
|-----|------|----------|------------|
| `--from` | path \| glob | yes | must resolve to ≥1 file |
| `--into` | path | no | parent dir must exist |
| `--onSupply` | `kernelize` \| `null` | no | must be known operation |
| `--onPress` | json array | no | must parse as valid step array |
| `--onVerify` | `restore` \| `null` | no | must be known operation |
| `--attempts` | number | no | must be ≥1 |
| `--mode` | `plan` \| `apply` | no | must be one of two values |
| `--brain` | string | no | must be known provider |

---

## contract.outputs

| metric | type | always present |
|--------|------|----------------|
| `dens.Δ` | number | yes (if kernelized) |
| `dens.σ` | number | yes (if attempts > 1) |
| `kern.Δ` | number | yes (if kernelized) |
| `kern.σ` | number | yes (if attempts > 1) |
| `tokens` | string (before → after) | yes |

---

## contract.exit-codes

| code | meaning |
|------|---------|
| 0 | success |
| 1 | generic error (invalid input, file not found, provider error) |
| 2 | kernelization unstable (brief too ambiguous) |
| 3 | kernel loss exceeded threshold (future: configurable) |
| 4 | verification failed |
