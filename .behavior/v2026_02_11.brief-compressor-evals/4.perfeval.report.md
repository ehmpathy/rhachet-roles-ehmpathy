# perfeval report: methodology brief comparison

## summary

evaluated 8 single-call methodology combinations and 1 chained pipeline for bhrain/sitrep compression across 5 representative briefs with 3 runs each (135 total compressions).

**winner: `[[sitrep-aggressive], [tsc]]` (chained) at 2.74x mean compression**

this represents a **66% improvement** over baseline `[sitrep]` (1.65x).

## results: single-call combinations

| combination               | mean      | min   | max   | stddev |
| ------------------------- | --------- | ----- | ----- | ------ |
| [sitrep-aggressive]       | 2.64x     | 1.32x | 5.99x | 1.26   |
| [sitrep-aggressive, tsc]  | 2.54x     | 1.32x | 5.51x | 1.18   |
| [sitrep-taskaware]        | 2.02x     | 1.16x | 4.20x | 0.67   |
| [sitrep-iterative]        | 1.74x     | 1.34x | 2.17x | 0.22   |
| [sitrep]                  | 1.65x     | 1.06x | 2.08x | 0.28   |
| [tsc, sitrep]             | 1.62x     | 1.20x | 2.39x | 0.31   |
| [sitrep, tsc, sitrep]     | 1.53x     | 1.23x | 2.30x | 0.31   |
| [sitrep, tsc]             | 1.38x     | 1.05x | 1.75x | 0.19   |

## results: chained pipeline

| pipeline                       | mean      | min   | max   | stddev |
| ------------------------------ | --------- | ----- | ----- | ------ |
| **[[sitrep-aggressive], [tsc]]** | **2.74x** | 1.76x | 4.75x | 0.92   |

### pass-by-pass breakdown

`[[sitrep-aggressive], [tsc]]`:
- pass 1 (sitrep-aggressive): 2.32x mean (1.16x - 4.21x)
- pass 2 (tsc on compressed): 1.21x mean (1.02x - 1.52x)

## key observations

### chained compression beats single-call

- **[[sitrep-aggressive], [tsc]] achieves 2.74x** — best overall
- pass 1 does abstractive compression (sitrep-aggressive)
- pass 2 applies extractive cleanup (tsc to drop articles)
- total ratio = pass1 × pass2, with compound gains

### single-call combined underperforms

- `[sitrep-aggressive, tsc]` at 2.54x vs chained 2.74x
- briefs combined in one call dilute focus
- sequential passes allow each methodology to fully apply

### explicit targets win

- sitrep-aggressive uses "≤25% of original" explicit target
- achieves 2.64x solo vs baseline sitrep's 1.65x (60% improvement)
- high variance (1.26) acceptable for best mean

### tsc works better as cleanup pass

- tsc alone underperforms as primary compressor
- but as second pass on already-compressed content, adds 1.21x
- extractive (tsc) + abstractive (sitrep) synergize when sequenced

## methodology

- **brain**: xai/grok/code-fast-1
- **sample**: 5 briefs from mechanic role (rule, concept, lesson, tactic types)
- **runs**: 3 per combination for statistical significance
- **concurrency**: 30 parallel calls via bottleneck
- **single-call duration**: ~227s total (~1.9s avg per compression)
- **chained duration**: ~129s total (~8.6s avg per chained compression)
- **success rate**: 135/135 (100%)

## experimental methodology variants

### sitrep-aggressive

targets ≤25% of original (4x compression). preserves only rule statement, one example, enforcement level. cuts all motivation prose and duplicate examples.

### sitrep-taskaware

explains downstream use case: agent context window consumption. describes what agents need vs don't need.

### sitrep-iterative

explicit two-pass approach: extract decision-critical content, then compress further. removes articles, filler verbs, collapses prose to bullets.

### tsc (extractive)

telegraphic semantic compression. drops articles, filler words, collapses to telegram-style prose. works best as cleanup pass after abstractive compression.

## recommendation

**production default**: use `[[sitrep-aggressive], [tsc]]` (chained)

1. achieves best mean compression ratio (2.74x)
2. two-pass approach: abstractive first, extractive cleanup second
3. pass 2 adds ~21% additional compression on already-compressed content
4. accept higher latency (2 brain calls) for better compression

**single-call alternative**: use `[sitrep-aggressive]` when latency matters

1. achieves 2.64x in single call
2. ~3x faster than chained (1 call vs 2)
3. only 4% worse compression than chained

**consistency-critical**: use `[sitrep-iterative]`

1. lowest variance (stddev 0.22)
2. predictable 1.74x compression
3. good for contexts where compression ratio must be stable

## retention measurement

a `extractKernels` skill is now available to measure semantic retention:

- extracts distinct concept kernels from documents
- compares original vs compressed to calculate retention ratio
- run via: `npm run test:integration:non-cicd -- extractKernels`

## research sources

experimental variants informed by:
- [Style-Compress: task-specific compression styles](https://arxiv.org/html/2410.14042v1)
- [LLMLingua: llm efficiency with prompt compression](https://www.microsoft.com/en-us/research/blog/llmlingua-innovating-llm-efficiency-with-prompt-compression/)
- [SCOPE: generative summarization for compression](https://www.arxiv.org/pdf/2508.15813)

## raw data

run via:
```sh
npm run test:integration:non-cicd -- compress.via.bhrain.perfeval
```
