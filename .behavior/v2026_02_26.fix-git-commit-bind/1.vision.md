# vision: git.commit.bind branch inference + feat safety nudge

## the outcome world

### day-in-the-life with this in place

vlad creates a branch `vlad/fix-auth-token-refresh`. mechanic works on the fix, stages changes, and commits:

```sh
echo "fix(auth): handle token refresh edge case

- added retry logic for expired tokens
- covered edge case where refresh fails mid-request" | npx rhachet run --skill git.commit.set -m @stdin --mode apply
```

`git.commit.set` calls `git.commit.bind get` internally to determine the effective level. since the branch name contains `fix`, the level is inferred automatically. the commit header is validated, and the commit proceeds. mechanic doesn't think about any of this â€” it just commits. no manual `git.commit.bind set --level fix` needed.

### before/after contrast

**before (no guardrails without explicit bind)**
```sh
# branch name: vlad/fix-api-validation
# no bind set â†’ mechanic can use ANY prefix
# mechanic defaults to feat (even though it's clearly a fix)
echo "feat(api): add validation" | npx rhachet run --skill git.commit.set -m @stdin --mode apply
# â†’ mislabeled commit lands in repo

# human CAN bind explicitly, but it's ceremony they often skip:
npx rhachet run --skill git.commit.bind set --level fix
# â†’ now mechanic is constrained, but who remembers to do this?
```

**after (inference + safety nudge)**
```sh
# branch name: vlad/fix-api-validation
# git.commit.bind get â†’ infers level = fix from branch name
# mechanic just commits â€” git.commit.set validates and proceeds

# branch name: vlad/feat-user-dashboard
# git.commit.bind get â†’ infers level = feat from branch name
# mechanic just commits â€” git.commit.set validates and proceeds

# branch name: vlad/refactor-utils (no fix/feat signal)
# git.commit.bind get â†’ level = (none)
# mechanic tries: feat(utils): add helper
# git.commit.set blocks with hard-nudge: "are you certain this is a feat?"
# mechanic must retry with --promise is-netnew-behavior to confirm
```

### the "aha" moment

the value clicks when:
1. you realize mechanics no longer default to `feat` for all commits â€” the branch name guides them
2. on a `fix-*` branch, mechanic can't accidentally commit as `feat` â€” the skill validates
3. on an ambiguous branch, mechanic must explicitly promise it's net-new behavior to use `feat`
4. you haven't manually bound a level in weeks â€” it just works

---

## user experience

### usecases

| goal | how | outcome |
|------|-----|---------|
| commit a fix on a fix branch | just commit | inferred, validated |
| commit a feat on a feat branch | just commit | inferred, validated |
| override inference | `git.commit.bind set --level X` | explicit wins |
| commit feat on ambiguous branch | `--promise is-netnew-behavior` | confirmed intentional |
| commit fix on ambiguous branch | just commit | no nudge (fix is safer default) |

### contract inputs & outputs

**git.commit.bind get** (enhanced with inference)
```
ðŸ¢ lets check the bind...

ðŸŒŠ git.commit.bind
   â”œâ”€ level: fix
   â””â”€ source: inferred from branch (vlad/fix-auth-token)
```

or with explicit override:
```
ðŸ¢ lets check the bind...

ðŸŒŠ git.commit.bind
   â”œâ”€ level: feat
   â””â”€ source: explicit (.branch/.bind/git.commit.level)
```

or with no signal:
```
ðŸ¢ lets check the bind...

ðŸŒŠ git.commit.bind
   â””â”€ level: (none â€” will nudge on feat commits)
```

**git.commit.set** with hard-nudge (feat on ambiguous branch)
```
ðŸ¢ hold up, dude...

ðŸŒŠ git.commit.set
   â””â”€ âœ‹ nudge: feat requires confirmation

   your branch (vlad/refactor-utils) doesn't signal fix or feat.

   are you certain this is a feat?
   - feat = net-new behavior that did not exist before
   - fix = covers a gap, tunes implementation, or corrects a defect

   if this is truly a feat, retry with:
     --promise is-netnew-behavior

   if this is a fix, change your commit header to fix(...):
```

### timeline

1. **create branch** â†’ name signals intent (or doesn't)
2. **work on changes** â†’ stage as usual
3. **commit** â†’ mechanic invokes `git.commit.set`, which internally:
   - calls `git.commit.bind get` to get effective level
   - explicit bind? â†’ use it
   - no explicit bind? â†’ infer from branch name
   - still no signal + feat commit? â†’ hard-nudge
   - mechanic is unaware of this logic â€” it just commits
4. **proceed or confirm** â†’ smooth flow or deliberate promise

---

## mental model

### how users describe this to a friend

> "the commit skill figures out if you're on a fix or feat from your branch name. mechanic just commits â€” the skill does all the validation. if it can't tell and mechanic tries to commit a feat, the skill makes it pinky-promise that it's really new functionality."

### analogies

- **traffic light inference**: the branch name is like a lane marker â€” stay in your lane and the light is green. switch lanes without a signal? the guardrail warns you.
- **spell-check for commit types**: just like spell-check catches "teh" without you asking, the skill catches "feat" when you meant "fix" â€” mechanic doesn't even realize it was about to mislabel

### terms alignment

| user says | we say |
|-----------|--------|
| "my branch name" | branch name pattern |
| "the level" | bound level |
| "it figured it out" | inferred from branch |
| "it asked me to confirm" | hard-nudge |
| "i promised" | `--promise is-netnew-behavior` |

---

## evaluation

### how well does it solve the goals?

| goal | solved? | how |
|------|---------|-----|
| reduce manual bind ceremony | âœ… | inference from branch name |
| prevent mislabeled commits | âœ… | validation + nudge |
| preserve human authority | âœ… | explicit bind overrides inference |
| pit of success for fixes | âœ… | fix allowed without nudge |
| deliberate feats | âœ… | feat requires signal or promise |

### pros

- **zero-ceremony for convention followers**: name your branch well, never think about bind again
- **catches mistakes**: mislabeled commits caught before they land
- **self-evident**: branch names become clear signals
- **reversible**: explicit bind always wins if inference is wrong

### cons

- **new flag to learn**: `--promise is-netnew-behavior`
- **branch name discipline**: benefits compound with good names
- **extra step on ambiguous branches**: feat commits need confirmation

### edgecases and pit of success

| edgecase | behavior | why safe |
|----------|----------|----------|
| branch: `main` | no inference, nudge on feat | main shouldn't have direct commits |
| branch: `hotfix/xyz` | infer fix | hotfix implies fix |
| branch: `feature/xyz` | infer feat | feature implies feat |
| branch: `vlad/fix-then-feat` | infer fix (first match wins) | ambiguous = safer default |
| branch: `release/1.0` | no inference, nudge on feat | releases are maintenance |
| explicit bind + inference conflict | explicit wins | human authority preserved |

### supported branch patterns

| pattern | inferred level |
|---------|----------------|
| `feat/xyz` | feat |
| `fix/xyz` | fix |
| `$name/feat/xyz` | feat |
| `$name/fix/xyz` | fix |
| `$name/feat-xyz` | feat |
| `$name/fix-xyz` | fix |
| `feature/xyz` | feat |
| `hotfix/xyz` | fix |
| `bugfix/xyz` | fix |

all other patterns â†’ no inference â†’ nudge on feat

---

## how the skills interact

### git.commit.bind

**current behavior:**
- `set --level fix|feat` â†’ writes explicit bind to `.branch/.bind/git.commit.level`
- `get` â†’ reads explicit bind from file
- `del` â†’ removes explicit bind

**new behavior:**
- `get` â†’ returns effective level with source:
  1. if explicit bind exists â†’ return it (source: explicit)
  2. else if branch name matches pattern â†’ infer level (source: inferred)
  3. else â†’ return none

### git.commit.set

**current behavior:**
- reads `.branch/.bind/git.commit.level` directly
- validates commit header matches bound level
- blocks if mismatch

**new behavior:**
- calls `git.commit.bind get` internally (or equivalent logic)
- validates commit header matches effective level
- if no level and commit header is `feat(...)`:
  - check for `--promise is-netnew-behavior` flag
  - if flag absent â†’ hard-nudge and block
  - if flag present â†’ proceed
- if no level and commit header is `fix(...)` â†’ proceed (fix is safe default)

---

## awkwardness uncovered

1. **"is-netnew-behavior" is verbose**: but verbosity is intentional â€” it's a speed bump to make you think
2. **what about `chore`, `docs`, `refactor`?**: these aren't fix or feat â€” no nudge, no validation (or should there be?)
3. **branch rename mid-work**: inference uses current branch name, not original â€” could cause confusion if branch was renamed
4. **merge commits**: what level applies? probably should skip validation on merges

---

## summary

this vision delivers:
1. **inference**: `git.commit.bind get` infers level from branch name when no explicit bind
2. **validation**: `git.commit.set` validates commit header matches effective level
3. **hard-nudge**: `git.commit.set` blocks feat without signal, requires `--promise is-netnew-behavior`
4. **explicit override**: `git.commit.bind set` always wins over inference
5. **transparent to mechanic**: mechanic just commits â€” skills handle all the logic

the pit of success: fixes flow freely, feats require intention. mechanic doesn't even think about it.
