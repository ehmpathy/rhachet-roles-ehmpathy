# blackbox criteria: git.commit.bind inference + feat safety nudge

## usecase.1 = infer level from branch name

```
given(branch name contains fix signal)
  # patterns: fix/*, */fix/*, */fix-*

  when(mechanic queries bound level)
    then(level = fix, source = inferred)
      sothat(mechanic knows the effective constraint)

  when(mechanic commits with fix(...) header)
    then(commit proceeds)
      sothat(valid commits are not blocked)

  when(mechanic commits with feat(...) header)
    then(commit is blocked with mismatch error)
      sothat(mislabeled commits are prevented)

  when(mechanic commits with chore/docs/refactor header)
    then(commit proceeds)
      sothat(only fix vs feat is validated)

given(branch name contains feat signal)
  # patterns: feat/*, */feat/*, */feat-*

  when(mechanic queries bound level)
    then(level = feat, source = inferred)

  when(mechanic commits with feat(...) header)
    then(commit proceeds)

  when(mechanic commits with fix(...) header)
    then(commit is blocked with mismatch error)

  when(mechanic commits with chore/docs/refactor header)
    then(commit proceeds)
      sothat(only fix vs feat is validated)
```

## usecase.2 = explicit bind overrides inference

```
given(branch name contains fix signal)
  given(human has explicitly bound level = feat)

    when(mechanic queries bound level)
      then(level = feat, source = explicit)
        sothat(human authority is preserved)

    when(mechanic commits with feat(...) header)
      then(commit proceeds)
        sothat(explicit bind takes precedence)

    when(mechanic commits with fix(...) header)
      then(commit is blocked with mismatch error)
```

## usecase.3 = hard-nudge on feat without signal

```
given(branch name has no fix/feat signal)
  # e.g., main, release/*, refactor-*, */chore-*

  when(mechanic queries bound level)
    then(level = none)

  when(mechanic commits with fix(...) header)
    then(commit proceeds)
      sothat(fix is the safe default — no nudge required)

  when(mechanic commits with feat(...) header)
    then(commit is blocked with hard-nudge)
    then(nudge message explains fix vs feat distinction)
    then(nudge instructs: retry with --promise is-netnew-behavior)
      sothat(mechanic must deliberately confirm net-new behavior)

  when(mechanic commits with feat(...) header AND --promise is-netnew-behavior)
    then(commit proceeds)
      sothat(deliberate feats are allowed after confirmation)

  when(mechanic commits with chore/docs/refactor header)
    then(commit proceeds)
      sothat(only fix vs feat is validated)
```

## usecase.4 = explicit bind on ambiguous branch

```
given(branch name has no fix/feat signal)
  given(human has explicitly bound level = feat)

    when(mechanic commits with feat(...) header)
      then(commit proceeds without nudge)
        sothat(explicit bind removes need for promise)

    when(mechanic commits with fix(...) header)
      then(commit is blocked with mismatch error)
```

## usecase.5 = query bound level shows source

```
given(no explicit bind AND branch = vlad/fix-auth)
  when(mechanic queries bound level)
    then(output shows level = fix)
    then(output shows source = inferred from branch)

given(explicit bind = feat AND branch = vlad/fix-auth)
  when(mechanic queries bound level)
    then(output shows level = feat)
    then(output shows source = explicit)

given(no explicit bind AND branch = main)
  when(mechanic queries bound level)
    then(output shows level = none)
    then(output notes: will nudge on feat commits)
```

## boundary conditions

```
given(branch = vlad/fix-then-feat)
  # ambiguous — contains both signals
  when(mechanic queries bound level)
    then(level = none)
      sothat(ambiguous branches are treated as no signal)

  when(mechanic commits with feat(...) header)
    then(commit is blocked with hard-nudge)
      sothat(ambiguous branches require deliberate confirmation for feat)

given(merge commit)
  when(mechanic creates merge commit)
    then(no level validation occurs)
      sothat(merge commits are not blocked)
```
