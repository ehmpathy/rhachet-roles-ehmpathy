# roadmap: git.commit.bind inference + feat safety nudge

## phase 0: preparation

### read before phase 0
- `.behavior/v2026_02_26.fix-git-commit-bind/3.3.blueprint.v1.i1.md`

### checklist
- [ ] verify current git.commit.bind.sh and git.commit.set.sh exist
- [ ] verify tests compile: `npm run build`
- [ ] verify tests pass: `npm run test:integration -- git.commit`

### acceptance criteria
- build passes
- extant tests pass

---

## phase 1: add branch inference to git.commit.bind.sh

### read before phase 1
- `.behavior/v2026_02_26.fix-git-commit-bind/3.3.blueprint.v1.i1.md` (codepath: git.commit.bind.sh)
- `.behavior/v2026_02_26.fix-git-commit-bind/2.1.criteria.blackbox.md` (usecase.1, usecase.5)

### checklist
- [ ] add `infer_level_from_branch()` helper function
- [ ] update `get` command to:
  1. check explicit bind file first
  2. if not found, infer from branch name
  3. return level + source (explicit|inferred|none)
- [ ] update output format to show source

### acceptance criteria
```
given branch = vlad/fix-auth
  when git.commit.bind get
    then level = fix, source = inferred

given branch = feat/dashboard
  when git.commit.bind get
    then level = feat, source = inferred

given branch = vlad/fix-then-feat (ambiguous)
  when git.commit.bind get
    then level = none

given explicit bind = feat AND branch = vlad/fix-auth
  when git.commit.bind get
    then level = feat, source = explicit
```

### verification
```sh
# manual test on fix branch
git checkout -b test/fix-inference
npx rhachet run --skill git.commit.bind get
# expect: level = fix, source = inferred

# manual test on feat branch
git checkout -b test/feat-inference
npx rhachet run --skill git.commit.bind get
# expect: level = feat, source = inferred
```

---

## phase 2: add validation + hard-nudge to git.commit.set.sh

### read before phase 2
- `.behavior/v2026_02_26.fix-git-commit-bind/3.3.blueprint.v1.i1.md` (codepath: git.commit.set.sh)
- `.behavior/v2026_02_26.fix-git-commit-bind/2.1.criteria.blackbox.md` (usecase.1-4)

### checklist
- [ ] add `--promise is-netnew-behavior` flag parse logic
- [ ] add `is_merge_commit()` helper function
- [ ] add `get_commit_prefix()` helper function
- [ ] update validation logic:
  1. get effective level (call git.commit.bind get or inline)
  2. skip validation for merge commits
  3. skip validation for chore/docs/refactor
  4. if level = fix: block feat commits (mismatch)
  5. if level = feat: block fix commits (mismatch)
  6. if level = none + feat commit: require --promise or block with hard-nudge
- [ ] add hard-nudge output format

### acceptance criteria
```
given branch = vlad/fix-auth
  when commit with fix(...) header
    then commit proceeds

  when commit with feat(...) header
    then blocked with mismatch error

given branch = vlad/refactor-utils (no signal)
  when commit with feat(...) header
    then blocked with hard-nudge

  when commit with feat(...) + --promise is-netnew-behavior
    then commit proceeds

  when commit with fix(...) header
    then commit proceeds (no nudge)

given merge commit
  then no validation occurs
```

### verification
```sh
# manual test: fix branch + fix commit
git checkout -b test/fix-validation
echo "test" > test.txt && git add test.txt
echo "fix(test): add test file

- added test.txt" | npx rhachet run --skill git.commit.set -m @stdin --mode plan
# expect: plan shows commit would proceed

# manual test: no signal + feat commit (should nudge)
git checkout -b test/nudge-validation
echo "test" > test.txt && git add test.txt
echo "feat(test): add test file

- added test.txt" | npx rhachet run --skill git.commit.set -m @stdin --mode plan
# expect: blocked with hard-nudge
```

---

## phase 3: add integration tests

### read before phase 3
- `.behavior/v2026_02_26.fix-git-commit-bind/3.3.blueprint.v1.i1.md` (test coverage section)
- `.behavior/v2026_02_26.fix-git-commit-bind/2.1.criteria.blackbox.md` (all usecases)

### checklist
- [ ] add/update `git.commit.bind.integration.test.ts`:
  - case1: branch with fix signal
  - case2: branch with feat signal
  - case3: explicit bind overrides inference
  - case4: ambiguous branch
  - case5: no signal branch
- [ ] add/update `git.commit.set.integration.test.ts`:
  - case1: fix branch + fix commit
  - case2: fix branch + feat commit (blocked)
  - case2b: feat branch + feat commit
  - case2c: feat branch + fix commit (blocked)
  - case3: no signal + feat commit (nudge), with --promise (proceeds)
  - case4: no signal + fix commit (proceeds)
  - case5: merge commit (skipped)
  - case6: chore/docs/refactor commits (proceed)
  - case7: explicit bind on ambiguous branch
  - case8: explicit bind overrides inference

### acceptance criteria
- all 15 test cases pass
- `npm run test:integration -- git.commit` passes

### verification
```sh
npm run test:integration -- git.commit.bind.integration.test.ts
npm run test:integration -- git.commit.set.integration.test.ts
```

---

## phase 4: build, link, smoke test

### read before phase 4
- (none required)

### checklist
- [ ] `npm run build`
- [ ] `npx rhachet roles link --role mechanic`
- [ ] `npx rhachet roles init --role mechanic`
- [ ] manual smoke test all scenarios

### acceptance criteria
- build passes
- link succeeds
- smoke tests pass for:
  - fix branch inference
  - feat branch inference
  - explicit bind override
  - hard-nudge on feat without signal
  - --promise bypass

### verification
```sh
npm run build
npx rhachet roles link --role mechanic
npx rhachet roles init --role mechanic

# smoke test
git checkout -b smoke/fix-test
npx rhachet run --skill git.commit.bind get
# expect: level = fix, source = inferred
```

---

## dependencies

```
phase 0 (preparation)
    │
    ▼
phase 1 (git.commit.bind.sh)
    │
    ▼
phase 2 (git.commit.set.sh)
    │
    ▼
phase 3 (integration tests)
    │
    ▼
phase 4 (build + smoke test)
```

phases must be executed in order. each phase depends on the previous.

