# blackbox criteria matrix: git.commit.bind inference + feat safety nudge

## matrix 1: query bound level

dimensions:
- **ind: branch signal** — fix, feat, none, ambiguous
- **ind: explicit bind** — none, fix, feat
- **dep: effective level** — fix, feat, none
- **dep: source** — inferred, explicit, n/a

| ind: branch signal | ind: explicit bind | dep: level | dep: source |
|--------------------|-------------------|------------|-------------|
| fix                | none              | fix        | inferred    |
| fix                | fix               | fix        | explicit    |
| fix                | feat              | feat       | explicit    |
| feat               | none              | feat       | inferred    |
| feat               | fix               | fix        | explicit    |
| feat               | feat              | feat       | explicit    |
| none               | none              | none       | n/a         |
| none               | fix               | fix        | explicit    |
| none               | feat              | feat       | explicit    |
| ambiguous          | none              | none       | n/a         |
| ambiguous          | fix               | fix        | explicit    |
| ambiguous          | feat              | feat       | explicit    |

**notes:**
- explicit bind always wins over inference
- ambiguous branches (both fix and feat signals) are treated as no signal


## matrix 2: commit validation (regular commits)

dimensions:
- **ind: effective level** — fix, feat, none
- **ind: commit header** — fix(...), feat(...), other (chore/docs/refactor)
- **ind: promise flag** — absent, present
- **dep: outcome** — proceeds, blocked:mismatch, blocked:hard-nudge

| ind: effective level | ind: commit header | ind: promise flag | dep: outcome |
|---------------------|-------------------|-------------------|--------------|
| fix                 | fix(...)          | absent            | proceeds     |
| fix                 | fix(...)          | present           | proceeds     |
| fix                 | feat(...)         | absent            | blocked:mismatch |
| fix                 | feat(...)         | present           | blocked:mismatch |
| fix                 | other             | absent            | proceeds     |
| fix                 | other             | present           | proceeds     |
| feat                | fix(...)          | absent            | blocked:mismatch |
| feat                | fix(...)          | present           | blocked:mismatch |
| feat                | feat(...)         | absent            | proceeds     |
| feat                | feat(...)         | present           | proceeds     |
| feat                | other             | absent            | proceeds     |
| feat                | other             | present           | proceeds     |
| none                | fix(...)          | absent            | proceeds     |
| none                | fix(...)          | present           | proceeds     |
| none                | feat(...)         | absent            | blocked:hard-nudge |
| none                | feat(...)         | present           | proceeds     |
| none                | other             | absent            | proceeds     |
| none                | other             | present           | proceeds     |

**notes:**
- promise flag only affects feat(...) commits when effective level = none
- other commit types (chore/docs/refactor) always proceed — only fix vs feat is validated
- when level = none, fix proceeds without nudge (safe default)


## matrix 3: merge commits

dimensions:
- **ind: commit type** — merge
- **dep: validation** — skipped

| ind: commit type | dep: validation |
|-----------------|-----------------|
| merge           | skipped         |

**notes:**
- merge commits bypass all level validation regardless of branch or bind state


## gap analysis

**all combinations covered** — no gaps found.

the matrices above enumerate all meaningful permutations of:
1. branch signal × explicit bind → query result
2. effective level × commit header × promise flag → commit outcome
3. merge commits → validation skipped


## decomposition assessment

**dimensions count:** 3 independent variables for commit validation (effective level, commit header, promise flag)

**verdict:** ✅ manageable — no decomposition needed

the behavioral boundary is well-scoped:
- single concern: commit level validation
- clear inputs: branch name, explicit bind, commit header, promise flag
- clear outputs: proceed or block (with reason)
