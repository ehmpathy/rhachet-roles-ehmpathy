# blueprint: git.commit.bind inference + feat safety nudge

## filediff treestruct

```
src/domain.roles/mechanic/skills/git.commit/
â”œâ”€ [~] git.commit.bind.sh                    # add inference logic to `get`
â”œâ”€ [~] git.commit.set.sh                     # add --promise flag, hard-nudge
â”œâ”€ [~] git.commit.bind.integration.test.ts   # add inference + nudge tests
â””â”€ [~] git.commit.set.integration.test.ts    # add promise flag tests
```

## codepath treestruct

### git.commit.bind.sh

```
[~] get_bound_level()
    â”œâ”€ [â—‹] check explicit bind file
    â”‚       â””â”€ if found â†’ return (level, source=explicit)
    â”œâ”€ [+] infer from branch name
    â”‚       â”œâ”€ get current branch: git rev-parse --abbrev-ref HEAD
    â”‚       â”œâ”€ match fix patterns: fix/*, */fix/*, */fix-*, hotfix/*, bugfix/*
    â”‚       â”‚   â””â”€ if match â†’ return (level=fix, source=inferred)
    â”‚       â”œâ”€ match feat patterns: feat/*, */feat/*, */feat-*, feature/*
    â”‚       â”‚   â””â”€ if match â†’ return (level=feat, source=inferred)
    â”‚       â””â”€ check ambiguous (both signals present)
    â”‚           â””â”€ if ambiguous â†’ return (level=none, source=n/a)
    â””â”€ [~] no signal
            â””â”€ return (level=none, source=n/a)
```

### git.commit.set.sh

```
[~] validate_commit_level()
    â”œâ”€ [+] parse --promise flag
    â”œâ”€ [~] get effective level (via git.commit.bind get or inline logic)
    â”œâ”€ [â—‹] extract commit header prefix (fix|feat|chore|docs|refactor|...)
    â”œâ”€ [+] if merge commit â†’ skip validation
    â”œâ”€ [+] if prefix is chore|docs|refactor â†’ proceed (no validation)
    â”œâ”€ [â—‹] if effective level = fix
    â”‚       â”œâ”€ if prefix = fix â†’ proceed
    â”‚       â””â”€ if prefix = feat â†’ block:mismatch
    â”œâ”€ [â—‹] if effective level = feat
    â”‚       â”œâ”€ if prefix = feat â†’ proceed
    â”‚       â””â”€ if prefix = fix â†’ block:mismatch
    â””â”€ [+] if effective level = none
            â”œâ”€ if prefix = fix â†’ proceed
            â””â”€ if prefix = feat
                â”œâ”€ if --promise is-netnew-behavior â†’ proceed
                â””â”€ else â†’ block:hard-nudge
```

## contract specifications

### git.commit.bind get (enhanced)

**output format:**
```
ðŸ¢ lets check the bind...

ðŸŒŠ git.commit.bind
   â”œâ”€ level: fix|feat|(none)
   â””â”€ source: explicit|inferred from branch|(none â€” will nudge on feat commits)
```

**json output (for composition):**
```json
{
  "level": "fix|feat|none",
  "source": "explicit|inferred|none"
}
```

### git.commit.set --promise (new flag)

**usage:**
```sh
echo "feat(api): add endpoint" | git.commit.set -m @stdin --promise is-netnew-behavior
```

**hard-nudge output (when blocked):**
```
ðŸ¢ hold up, dude...

ðŸŒŠ git.commit.set
   â””â”€ âœ‹ nudge: feat requires confirmation

   your branch (vlad/refactor-utils) doesn't signal fix or feat.

   are you certain this is a feat?
   - feat = net-new behavior that did not exist before
   - fix = covers a gap, tunes implementation, or corrects a defect

   if this is truly a feat, retry with:
     --promise is-netnew-behavior

   if this is a fix, change your commit header to fix(...):
```

## branch pattern matching

### fix patterns (infer level=fix)
- `fix/*` â€” fix/auth-bug
- `*/fix/*` â€” vlad/fix/auth-bug
- `*/fix-*` â€” vlad/fix-auth-bug
- `hotfix/*` â€” hotfix/urgent-patch
- `bugfix/*` â€” bugfix/typo

### feat patterns (infer level=feat)
- `feat/*` â€” feat/new-api
- `*/feat/*` â€” vlad/feat/new-api
- `*/feat-*` â€” vlad/feat-new-api
- `feature/*` â€” feature/dashboard

### ambiguous (treat as none)
- branch contains both fix AND feat signals
- e.g., `vlad/fix-then-feat` â†’ level=none

### no signal (level=none)
- `main`, `master`
- `release/*`
- `refactor-*`, `*/chore-*`
- any other pattern

## test coverage

### git.commit.bind.integration.test.ts

```ts
given('[case1] branch with fix signal', () => {
  // setup: git checkout -b vlad/fix-auth
  when('[t0] get bound level', () => {
    then('level = fix', ...);
    then('source = inferred', ...);
  });
});

given('[case2] branch with feat signal', () => {
  // setup: git checkout -b feat/dashboard
  when('[t0] get bound level', () => {
    then('level = feat', ...);
    then('source = inferred', ...);
  });
});

given('[case3] explicit bind overrides inference', () => {
  // setup: git checkout -b vlad/fix-auth
  // setup: git.commit.bind set --level feat
  when('[t0] get bound level', () => {
    then('level = feat', ...);
    then('source = explicit', ...);
  });
});

given('[case4] ambiguous branch', () => {
  // setup: git checkout -b vlad/fix-then-feat
  when('[t0] get bound level', () => {
    then('level = none', ...);
  });
});

given('[case5] no signal branch', () => {
  // setup: git checkout -b main
  when('[t0] get bound level', () => {
    then('level = none', ...);
    then('output notes nudge warning', ...);
  });
});
```

### git.commit.set.integration.test.ts

```ts
given('[case1] fix branch + fix commit', () => {
  // setup: git checkout -b vlad/fix-auth
  when('[t0] commit with fix(...) header', () => {
    then('commit proceeds', ...);
  });
});

given('[case2] fix branch + feat commit', () => {
  // setup: git checkout -b vlad/fix-auth
  when('[t0] commit with feat(...) header', () => {
    then('commit blocked with mismatch error', ...);
  });
});

given('[case2b] feat branch + feat commit', () => {
  // setup: git checkout -b vlad/feat-dashboard
  when('[t0] commit with feat(...) header', () => {
    then('commit proceeds', ...);
  });
});

given('[case2c] feat branch + fix commit', () => {
  // setup: git checkout -b vlad/feat-dashboard
  when('[t0] commit with fix(...) header', () => {
    then('commit blocked with mismatch error', ...);
  });
});

given('[case3] no signal branch + feat commit', () => {
  // setup: git checkout -b vlad/refactor-utils
  when('[t0] commit with feat(...) header', () => {
    then('commit blocked with hard-nudge', ...);
  });
  when('[t1] commit with feat(...) + --promise', () => {
    then('commit proceeds', ...);
  });
});

given('[case4] no signal branch + fix commit', () => {
  // setup: git checkout -b main
  when('[t0] commit with fix(...) header', () => {
    then('commit proceeds (no nudge)', ...);
  });
});

given('[case5] merge commit', () => {
  when('[t0] create merge commit', () => {
    then('no level validation occurs', ...);
  });
});

given('[case6] chore/docs/refactor commits', () => {
  // setup: git checkout -b vlad/fix-auth
  when('[t0] commit with chore(...) header', () => {
    then('commit proceeds', ...);
  });
});

given('[case7] explicit bind on ambiguous branch', () => {
  // setup: git checkout -b vlad/refactor-utils
  // setup: git.commit.bind set --level feat
  when('[t0] commit with feat(...) header', () => {
    then('commit proceeds without nudge', ...);
  });
  when('[t1] commit with fix(...) header', () => {
    then('commit blocked with mismatch error', ...);
  });
});

given('[case8] explicit bind overrides fix branch inference', () => {
  // setup: git checkout -b vlad/fix-auth
  // setup: git.commit.bind set --level feat
  when('[t0] commit with feat(...) header', () => {
    then('commit proceeds (explicit bind wins)', ...);
  });
  when('[t1] commit with fix(...) header', () => {
    then('commit blocked with mismatch error', ...);
  });
});
```

## implementation notes

### branch pattern detection (bash)

```bash
infer_level_from_branch() {
  local branch="$1"

  # check for ambiguous (both fix and feat)
  local has_fix=false
  local has_feat=false

  if [[ "$branch" =~ ^fix/ ]] || [[ "$branch" =~ /fix/ ]] || [[ "$branch" =~ /fix- ]] || \
     [[ "$branch" =~ ^hotfix/ ]] || [[ "$branch" =~ ^bugfix/ ]]; then
    has_fix=true
  fi

  if [[ "$branch" =~ ^feat/ ]] || [[ "$branch" =~ /feat/ ]] || [[ "$branch" =~ /feat- ]] || \
     [[ "$branch" =~ ^feature/ ]]; then
    has_feat=true
  fi

  if $has_fix && $has_feat; then
    echo "none"  # ambiguous
  elif $has_fix; then
    echo "fix"
  elif $has_feat; then
    echo "feat"
  else
    echo "none"
  fi
}
```

### merge commit detection (bash)

```bash
is_merge_commit() {
  local parents
  parents=$(git cat-file -p HEAD 2>/dev/null | grep -c "^parent ")
  [[ "$parents" -gt 1 ]]
}
```

### commit header extraction (bash)

```bash
get_commit_prefix() {
  local header="$1"
  # extract prefix before (
  if [[ "$header" =~ ^([a-z]+)\( ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    echo ""
  fi
}
```

## edge cases

| case | behavior |
|------|----------|
| branch renamed mid-work | uses current branch name |
| detached HEAD | no branch â†’ level=none |
| explicit bind + del | removes bind, falls back to inference |
| --promise without feat header | ignored (only applies to feat) |
| --promise on bound branch | unnecessary but harmless |

## dependencies

- no new dependencies
- uses extant bash utilities: git, grep, regex matching

## rollout

1. update git.commit.bind.sh with inference logic
2. update git.commit.set.sh with validation + nudge
3. add integration tests
4. build and link
5. manual smoke test

