
# vision: boot.yml for mechanic role

## the outcome world

### before

today, `npx rhachet roles boot --repo ehmpathy --role mechanic` boots **all 102 briefs** (~61k tokens) into every session, regardless of what the mechanic is about to do.

- mechanic asked to write a unit test? gets all 59 production code briefs too.
- mechanic asked to review architecture? gets all 13 test briefs and 8 workflow briefs.
- mechanic asked to rename a variable? gets the full domain-objects reference doc (~3k tokens), the full declastruct demo (~4k tokens), and every tone/term brief.

the mechanic's context window fills with briefs it won't use. token cost scales linearly with brief count — not with relevance.

### after

a `boot.yml` on the mechanic role declares:
1. **subjects** — clusters of briefs by topic (test, prod, arch, lang, flow)
2. **modes** — whether each brief is `say`'d (full injection) or `ref`'d (link only)

the boot command can then:
- boot a specific subject: `npx rhachet roles boot --subject test`
- boot only the "always" briefs by default
- inject core rules in full (`--say`) while heavy references/demos stay as links (`--ref`)

### the "aha" moment

a mechanic session that needs to write tests boots ~15 briefs (test + always) instead of 102. context is focused. the rules that matter are present. the demos and references are a click away if needed. token cost drops from ~61k to ~15k per boot.

## user experience

### contract

```yaml
# boot.yml
subjects:
  always:
    - briefs/practices/lang.terms/define.directives...:  say
    - briefs/practices/lang.terms/rule.forbid.gerunds.md:  say
    - briefs/practices/lang.terms/rule.require.order.noun_adj.md:  say
    - briefs/practices/lang.terms/rule.require.ubiqlang.md:  say
    - briefs/practices/lang.tones/rule.im_an.ehmpathy_seaturtle.md:  say
    - briefs/practices/lang.tones/rule.prefer.lowercase.md:  say
    - briefs/practices/lang.tones/rule.require.term-human.md:  say
    # ...

  subject.prod:
    - briefs/practices/code.prod/evolvable.procedures/rule.require.input-context-pattern...:  say
    - briefs/practices/code.prod/evolvable.procedures/rule.require.arrow-only.md:  say
    - briefs/practices/code.prod/readable.narrative/rule.require.narrative-flow.md:  say
    - briefs/practices/code.prod/evolvable.domain.objects/ref.package.domain-objects...:  ref
    - briefs/practices/code.prod/readable.persistence/rule.prefer.declastruct...:  ref
    # ...

  subject.test:
    - briefs/practices/code.test/frames.behavior/rule.require.given-when-then.md:  say
    - briefs/practices/code.test/consistent.contracts/ref.package.test-fns...:  ref
    - briefs/practices/code.test/frames.behavior/howto.write-bdd...:  ref
    # ...
```

### invocation

```sh
# boot only the "always" cluster (identity, language, tone)
npx rhachet roles boot --repo ehmpathy --role mechanic

# boot always + test subject
npx rhachet roles boot --repo ehmpathy --role mechanic --subject test

# boot always + prod subject
npx rhachet roles boot --repo ehmpathy --role mechanic --subject prod

# boot always + arch subject
npx rhachet roles boot --repo ehmpathy --role mechanic --subject arch

# boot multiple subjects
npx rhachet roles boot --repo ehmpathy --role mechanic --subject prod --subject test
```

### timeline

1. human spawns a mechanic for test work
2. sessionstart hook fires `roles boot --subject test`
3. mechanic boots with ~15 briefs (always + test), mostly `say`'d rules with a few `ref`'d lessons
4. mechanic works with focused context
5. if mechanic needs prod knowledge mid-session, it can `roles boot --subject prod` to pull in more

## mental model

> "boot.yml is like a course syllabus — it lists what's required study (say) vs recommended reading (ref), organized by topic (subject)"

- **subjects** = course modules. you don't take every module at once.
- **say** = required study. you must internalize these rules to do the work.
- **ref** = recommended reading. you know where to find it when you need it.
- **always** = prerequisites. every module depends on these.

users would describe it as: "i can tell the mechanic what kind of work we're doing, and it only loads the briefs that matter."

## evaluation

### pros
- **dramatic token reduction** — from ~61k to ~10-20k per boot, depending on subject
- **focused context** — mechanic has the rules it needs, not noise from unrelated topics
- **say/ref split** — heavy reference docs (domain-objects, test-fns, declastruct demo) stay as links instead of flooding context
- **composable** — subjects can overlap; multiple subjects can be booted together
- **backwards compatible** — boot without `--subject` could boot "always" or everything

### cons
- **maintenance surface** — boot.yml must be kept in sync as briefs are added/removed
- **classification judgment** — some briefs are borderline between subjects
- **ref accessibility** — `ref`'d briefs require the mechanic to actively fetch them when needed

### edgecases
- **brief in multiple subjects** — allowed per the wish; overlap is fine
- **new brief added but not in boot.yml** — should fail loudly or warn at boot time
- **subject not recognized** — should fail fast with clear error
- **empty subject** — valid; allows progressive build-up

---

## proposed clustering

### subject: always (~21 briefs)

identity, language, and foundational terms that apply to everything.

| brief | mode | rationale |
|-------|------|-----------|
| `lang.terms/define.directives...` | say | foundational — defines enforcement levels |
| `lang.terms/rule.forbid.gerunds.md` | say | pervasive — applies to all naming |
| `lang.terms/rule.require.order.noun_adj.md` | say | pervasive — applies to all naming |
| `lang.terms/rule.require.ubiqlang.md` | say | pervasive — applies to all naming |
| `lang.terms/rule.require.treestruct.md` | say | pervasive — applies to all naming |
| `lang.terms/rule.forbid.term-dryrun` | say | pervasive — naming rule |
| `lang.terms/rule.forbid.term=dryrun` | ref | duplicate detail of above |
| `lang.terms/rule.forbid.term=existing` | say | pervasive — naming rule |
| `lang.terms/rule.forbid.term=normalize` | ref | reference — detailed alternatives table |
| `lang.terms/rule.forbid.term-script` | say | pervasive — naming rule |
| `lang.terms/rule.prefer.term-supplier.md` | ref | situational — only when naming mechanisms |
| `lang.terms/rule.require.order.noun_adj.pt2` | ref | supplement to pt1 which is say'd |
| `lang.terms/define.exec-vs-apply.md` | ref | reference — lookup when ambiguity arises |
| `lang.terms/define.prodcode-testcode...` | ref | reference — lookup when needed |
| `lang.tones/rule.im_an.ehmpathy_seaturtle.md` | say | identity — defines who the mechanic is |
| `lang.tones/rule.prefer.lowercase.md` | say | pervasive — applies to all output |
| `lang.tones/rule.require.term-human.md` | say | pervasive — applies to all communication |
| `lang.tones/rule.prefer.chill-nature-emojis.md` | say | pervasive — applies to all output |
| `lang.tones/rule.forbid.buzzwords.md` | say | pervasive — applies to all communication |
| `lang.tones/rule.forbid.shouts.md` | say | pervasive — applies to all naming |
| `lang.tones/define.why-seaturtles...` | ref | flavor — fun but not operationally critical |

### subject: subject.prod (~52 briefs)

production code: procedures, domain objects, architecture, errors, types, readability.

| brief | mode | rationale |
|-------|------|-----------|
| **evolvable.procedures/** | | |
| `rule.require.input-context-pattern.pt1` | say | core pattern — must be internalized |
| `rule.require.input-context-pattern.pt2` | ref | supplement — details on inline input |
| `rule.require.input-options-pattern` | say | core pattern — must be internalized |
| `rule.require.arrow-only` | say | core rule — pervasive |
| `rule.require.clear-contracts` | say | core rule — pervasive |
| `rule.require.dependency-injection.pt1` | say | core pattern — must be internalized |
| `rule.require.dependency-injection.pt2` | ref | supplement — additional rationale |
| `rule.require.hook-wrapper-pattern` | say | core pattern — must be internalized |
| `rule.require.named-args` | say | core rule — pervasive |
| `rule.require.single-responsibility` | say | core rule — pervasive |
| `rule.forbid.io-as-domain-objects` | say | core rule — pervasive |
| `rule.forbid.io-as-interfaces` | say | core rule — pervasive |
| `rule.forbid.positional-args.pt1` | say | core rule — pervasive |
| `rule.forbid.positional-args.pt2` | ref | supplement — additional rationale |
| **evolvable.domain.objects/** | | |
| `ref.package.domain-objects.[ref]` | ref | reference doc — heavy, lookup when needed |
| `rule.forbid.nullable-without-reason` | say | core rule — pervasive |
| `rule.forbid.undefined-attributes` | say | core rule — pervasive |
| `rule.require.immutable-refs` | say | core rule — pervasive |
| **evolvable.domain.operations/** | | |
| `define.domain-operation-core-variants` | ref | reference — only needed in brain-repl contexts |
| `rule.require.sync-filename-opname` | say | core rule — pervasive |
| **evolvable.architecture/** | | |
| `rule.prefer.wet-over-dry` | say | core philosophy — must be internalized |
| `rule.require.bounded-contexts` | ref | architecture — lookup when in design work |
| `rule.require.domain-driven-design` | ref | architecture — lookup when in design work |
| **evolvable.repo.structure/** | | |
| `rule.forbid.barrel-exports` | say | core rule — pervasive |
| `rule.forbid.index-ts` | say | core rule — pervasive |
| `rule.prefer.dot-dirs` | ref | nitpick level — ref is sufficient |
| `rule.require.directional-deps` | say | core rule — pervasive |
| **pitofsuccess.errors/** | | |
| `rule.forbid.error-hiding.pt1` | say | core rule — pervasive |
| `rule.forbid.error-hiding.pt2` | ref | supplement |
| `rule.prefer.helpful-error-wrap` | say | core pattern — must be internalized |
| `rule.require.fail-fast` | say | core rule — pervasive |
| `rule.require.fail-fast.[seed]` | ref | seed — supplementary rationale |
| `rule.require.fail-fast.[demo].shell` | ref | demo — lookup when in shell context |
| **pitofsuccess.procedures/** | | |
| `rule.forbid.nonidempotent-mutations` | say | core rule — pervasive |
| `rule.forbid.undefined-inputs` | say | core rule — pervasive |
| `rule.require.idempotent-procedures` | say | core rule — pervasive |
| `rule.require.idempotency.[seed]` | ref | seed — supplementary rationale |
| `rule.require.immutable-vars` | say | core rule — pervasive |
| `rule.require.pitofsuccess` | ref | philosophy — reference when in design work |
| **pitofsuccess.typedefs/** | | |
| `define.bivariance-for-generics.[lesson]` | ref | lesson — lookup when needed |
| `rule.forbid.as-cast` | say | core rule — pervasive |
| `rule.require.shapefit` | say | core rule — pervasive |
| **readable.comments/** | | |
| `rule.require.what-why-headers` | say | core rule — pervasive |
| `rule.require.what-why-headers.v1` | ref | older version — ref only |
| **readable.narrative/** | | |
| `rule.require.narrative-flow` | say | core rule — pervasive |
| `rule.avoid.unnecessary-ifs` | say | core rule — pervasive |
| `rule.forbid.else-branches` | say | core rule — pervasive |
| `rule.forbid.else-branches.[demo]` | ref | demo — lookup when needed |
| `rule.prefer.early-returns.[demo]` | ref | demo — lookup when needed |
| `rule.prefer.transformers-over-conditionals.[lesson]` | ref | lesson — lookup when needed |
| **readable.persistence/** | | |
| `rule.prefer.declastruct.[demo]` | ref | demo — heavy, lookup when in persistence context |
| **consistent.artifacts/** | | |
| `rule.require.pinned-versions` | say | core rule — pervasive |
| **consistent.contracts/** | | |
| `ref.package.as-command.[ref]` | ref | reference — lookup when needed |

### subject: subject.test (~16 briefs)

test code: bdd, given-when-then, data-driven, howtos.

| brief | mode | rationale |
|-------|------|-----------|
| **frames.behavior/** | | |
| `rule.require.given-when-then` | say | core pattern — must be internalized |
| `rule.require.useThen-useWhen-for-shared-results` | say | core pattern — must be internalized |
| `rule.forbid.redundant-expensive-operations` | say | core rule — pervasive in test code |
| `howto.write-bdd.[lesson]` | ref | lesson — detailed reference for bdd structure |
| `howto.write-bdd.[lesson].pt2` | ref | lesson — supplement |
| **frames.caselist/** | | |
| `rule.prefer.data-driven` | say | core pattern — must be internalized |
| **consistent.contracts/** | | |
| `ref.package.test-fns.[ref]` | ref | reference doc — heavy, lookup when needed |
| **lessons.howto/** | | |
| `howto.diagnose.[lesson]` | ref | lesson — lookup when in debug mode |
| `howto.run.[lesson]` | ref | lesson — lookup when first run |
| `howto.use.[lesson]` | ref | lesson — lookup when needed |
| `howto.write.[lesson].pt1` | say | core — short, must be internalized |
| `howto.write.[lesson].pt2` | say | core — short, must be internalized |
| `howto.write.[lesson].pt3` | say | core — short, must be internalized |
| `rule.require.snapshots.[lesson]` | say | core rule — must be internalized |
| **scope.acceptance/** | | |
| `rule.require.blackbox` | say | core rule — must be internalized |
| **scope.unit/** | | |
| `rule.forbid.remote-boundaries` | say | core rule — must be internalized |

### subject: subject.arch (~9 briefs, overlap with prod)

architecture, domain design, repo structure — for design-level work.

| brief | mode | rationale |
|-------|------|-----------|
| `rule.prefer.wet-over-dry` | say | core philosophy |
| `rule.require.bounded-contexts` | say | core architecture rule (say in arch, ref in prod) |
| `rule.require.domain-driven-design` | say | core architecture rule (say in arch, ref in prod) |
| `ref.package.domain-objects.[ref]` | say | reference — needed in full for arch work (say in arch, ref in prod) |
| `rule.forbid.nullable-without-reason` | say | domain design rule |
| `rule.forbid.undefined-attributes` | say | domain design rule |
| `rule.require.immutable-refs` | say | domain design rule |
| `rule.require.directional-deps` | say | architecture rule |
| `rule.prefer.declastruct.[demo]` | say | needed in full for arch work (say in arch, ref in prod) |

### subject: subject.flow (~10 briefs)

workflow, tools, diagnostics — for meta-work.

| brief | mode | rationale |
|-------|------|-----------|
| `howto.bisect.[lesson]` | ref | lesson — lookup when in debug mode |
| `rule.forbid.trust-vscode-diagnostics` | say | core rule |
| `rule.prefer.sedreplace-for-renames` | say | core tool guidance |
| `rule.require.review-test-changes` | say | core rule |
| `rule.prefer.allowlist-examples.[lesson]` | ref | lesson |
| `rule.prefer.jq.[demo]` | ref | demo |
| `rule.prefer.terraform.pt1` | say | core tool guidance |
| `rule.prefer.terraform.pt2` | ref | supplement |
| `rule.require.externalized-knowledge` | say | core rule |
| `rule.require.read-package-docs-before-use` | say | core rule |

---

## token estimates (rough)

| boot scenario | briefs say'd | briefs ref'd | est. tokens |
|---------------|-------------|-------------|-------------|
| always only | ~11 | ~10 | ~4k |
| always + test | ~20 | ~16 | ~10k |
| always + prod | ~35 | ~27 | ~20k |
| always + arch | ~19 | ~12 | ~12k |
| always + flow | ~17 | ~14 | ~8k |
| always + prod + test | ~45 | ~33 | ~25k |
| everything (current) | all 102 say'd | 0 | ~61k |

the biggest win: `ref`'d briefs contribute only a path line (~20 tokens) instead of full content (~500-3000 tokens each).
