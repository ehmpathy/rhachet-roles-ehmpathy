# vision: git.commit.bind --level

## the outcome world

### before

the human delegates work to the mechanic. they say "fix this bug" or "add this feature". the mechanic goes heads down, writes code, then commits.

```
human: "fix the validation bug in the login flow"
mechanic: *writes the fix, stages changes*
mechanic: git.commit.set -m "feat(auth): add retry logic\n\n- added retry on timeout"
[commit succeeds]
human: *reviews PR, sees "feat" prefix on a bug fix*
human: "wait... this was a fix, not a feat. the changelog is wrong now."
```

the mechanic meant well but picked the wrong conventional commit prefix. the human catches it in review — or worse, doesn't catch it and the changelog generates with wrong categorization.

this is especially painful when:
- the human has a clear intent ("this is a fix") but no way to express it as a constraint
- multiple commits land on a branch with mixed prefixes
- the release changelog groups changes by prefix — wrong prefix = wrong section

### after

the human binds a level before handoff.

```
human: $ git.commit.bind --level fix
human: "fix the validation bug in the login flow"
mechanic: *writes the fix, stages changes*
mechanic: git.commit.set -m "feat(auth): add retry logic\n\n- added retry"
[rejected: commit header must start with "fix" — level bound by human]
mechanic: git.commit.set -m "fix(auth): add retry on timeout\n\n- added retry"
[commit succeeds]
```

the mechanic gets immediate feedback. no wrong prefix reaches the branch. the changelog is correct by construction.

### the "aha" moment

the value clicks when the human realizes: "i set `--level fix` once, and every commit on this branch was correctly categorized — without me checking each one." the constraint is invisible when followed, loud when violated.

## user experience

### usecases

1. **bug fix branch** — human binds `--level fix`, all commits must be fixes
2. **feature branch** — human binds `--level feat`, all commits must be features
3. **no constraint** — human doesn't bind, mechanic can use any prefix (backwards compatible)

### contract

**bind**:

```sh
# set the level for all commits on this branch
git.commit.bind --level fix

# check what level is bound
git.commit.bind --level get

# clear the bound level
git.commit.bind --level clear
```

**storage**: `.bind/git.commit.level` in repo root — a plain text file with the level value.

**enforcement in git.commit.set**:

| bound level | commit header | result |
|-------------|---------------|--------|
| `fix` | `fix(api): validate input` | allowed |
| `fix` | `fix: validate input` | allowed |
| `fix` | `feat(api): add endpoint` | rejected |
| `feat` | `feat(ui): add button` | allowed |
| `feat` | `fix(ui): button color` | rejected |
| (none) | any prefix | allowed |

### timeline

```
t+0       human runs: git.commit.bind --level fix
t+0       .bind/git.commit.level written with "fix"
...
t+N       mechanic runs: git.commit.set -m "feat(...): ..."
t+N       git.commit.set reads .bind/git.commit.level
t+N       header prefix "feat" != bound level "fix"
t+N       error: "commit header must start with 'fix' — level bound by human"
t+N       mechanic corrects prefix and retries
```

## mental model

### how users describe it

> "i tell the turtle what kind of work this is — fix or feature — and it won't let commits through with the wrong label."

### analogies

**traffic lane markers**: you pick a lane (fix or feat) and the guardrails keep you in it. you can still drive freely within the lane, but you can't drift into the wrong one.

**commit linter**: like commitlint but simpler — one config, one constraint, enforced at the skill level rather than a git hook.

### terminology

| user term | our term |
|-----------|----------|
| "commit type" | level |
| "set the type" | bind the level |
| "clear the type" | clear the level |
| "wrong type" | level mismatch |

## evaluation

### how well does it solve the goals?

| goal | score | notes |
|------|-------|-------|
| prevent wrong prefix | excellent | hard enforcement at commit time |
| preserve flow | excellent | bind once, forget about it |
| backwards compatible | excellent | no bind = no enforcement |
| simple mental model | excellent | one command, one constraint |

### pros

1. **correctness by construction** — wrong prefixes are impossible once bound
2. **zero sustained effort** — human binds once per branch
3. **immediate feedback** — mechanic learns at commit time, not at review time
4. **backwards compatible** — no bind = prior behavior preserved
5. **simple storage** — plain text file, easy to inspect and debug

### cons

1. **only feat and fix** — limited to two levels initially
   - mitigation: extend later with chore, refactor, etc. if needed
2. **branch-scoped only** — bind applies to all commits on the branch
   - mitigation: human can clear and rebind if scope changes

### edgecases and pit of success

| edgecase | handle | user experience |
|----------|--------|-----------------|
| no `.bind/git.commit.level` | no enforcement | backwards compatible |
| level file is empty | no enforcement | treated as unbound |
| level is unknown value | reject at bind time | "error: --level must be 'feat' or 'fix'" |
| human wants mixed levels | clear the bind | `git.commit.bind --level clear` |
| mechanic tries to bind | denied by permissions | `.bind/` write denied in permissions |

the pit of success: the default path (no bind) is fully backwards compatible. when a human binds a level, the constraint is simple, loud on violation, and invisible on compliance.
