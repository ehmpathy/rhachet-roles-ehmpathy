# vision: keyrack

## the outcome world

### before

```
human: "push this fix please"
mechanic: "üê¢ shell yeah, on it..."
mechanic: "üê¢ bummer dude, i don't have EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN"
mechanic: "you'll have to push manually or set the env var"
human: *sighs, opens terminal, pushes manually*
```

the mechanic has the skill, the permission, the intent ‚Äî but not the key. the human is pulled back into the loop for a mechanical task they delegated.

### after

```
human: "push this fix please"
mechanic: "üê¢ cowabunga! pushed and pr created"
```

the mechanic doesn't even know the keyrack exists. the skill fetches the token invisibly, and the mechanic stays focused on what matters: the task at hand. the human stays in flow.

### the key insight: invisible infrastructure

the keyrack lives inside the skill, not in the mechanic's awareness. the mechanic doesn't think "fetch token, then push" ‚Äî they just think "push". the token acquisition is an implementation detail hidden behind the skill's contract.

this is the difference between:
- **visible**: "mechanic, here's a token, now push"
- **invisible**: "mechanic, push" (token handled automatically)

the mechanic's cognitive load stays on the work, not the wires.

### the "aha" moment

> "wait, it just... worked? no token errors?"

the value clicks when the first push succeeds without the human involved. the mechanic becomes a full collaborator, not a partial one that needs help at the last mile.

## user experience

### usecase 1: repo owner opts in

the human adds their trust declaration once:

```yaml
# .agent/keyrack.yml
extends:
  - .agent/repo=ehmpathy/role=mechanic/keyrack.yml
```

then unlocks the keyrack (human action, one-time):

```sh
rhachet keyrack unlock
# ‚Üí authenticates to host keystore
# ‚Üí keyrack ready for session
```

### usecase 2: mechanic pushes code

`git.commit.push.sh` now auto-fetches:

```bash
# before the token guard
EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN=$(
  ./node_modules/.bin/rhachet keyrack get \
    --key EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN \
    --json | jq -r '.key.secret'
)
```

keyrack is the source of truth ‚Äî no fallback. errors propagate with actionable messages.

### usecase 3: role author declares keys

in the roles repo, the mechanic role declares what keys it needs ‚Äî just names, no storage details:

```yaml
# src/domain.roles/mechanic/keyrack.yml
org: ehmpathy
env.prod:
  - EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN
env.test:
  - EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN
```

this is the beauty of keyrack:
- **portable**: role says "i need this key" ‚Äî not where it lives
- **secretive**: no storage details leak into committed files
- **isomorphic**: same spec works across dev machines and CI/CD

**how it works**: each machine has a `keyrack.host.manifest` ‚Äî an explicit registration of where keys live on that host.

| layer | declares | where | committed? |
|-------|----------|-------|------------|
| role keyrack | what keys i need | `keyrack.yml` | yes |
| host manifest | where keys live on this machine | `keyrack.host.manifest` | no (per-machine) |

the role spec says "i need X", the host manifest says "X lives here". no magic ‚Äî just explicit registration.

### separation of concerns

each layer only thinks about its part:

| layer | thinks about | doesn't care about |
|-------|--------------|-------------------|
| repo | which role keyracks to trust | keys, host storage |
| role | briefs, skills | keys |
| skill | "i need this key" | where it's stored |
| host | where keys live here | which skills need them |

the repo doesn't think about the host manifest ‚Äî only their repo manifest. the role doesn't think about keys at all ‚Äî only the skill does. clean layers, decoupled.

this spec gets distributed via build ‚Üí dist ‚Üí symlink, just like briefs and skills.

### timeline

1. **role author** (once): declares key spec in `keyrack.yml`
2. **repo owner** (once): extends role keyrack in `.agent/keyrack.yml`
3. **human** (per session): unlocks keyrack
4. **mechanic** (every push): automatically fetches token, completes operation

## mental model

### analogy: the key hook by the door

the keyrack is like the hook by your front door where you hang your car keys.

- you (human) put the keys there
- members of your household (trusted roles) can grab them when needed
- you decide who has access to the house
- the keys aren't scattered around ‚Äî they're in one known place

### terms

| we say | users might say |
|--------|-----------------|
| keyrack | key store, secrets, credentials |
| extends | trusts, includes, imports |
| unlock | authenticate, login |
| key spec | key config, secret definition |

### elevator pitch

> "keyrack gives skills access to tokens invisibly. the mechanic never knows it's there ‚Äî they just focus on the work. you opt-in once, unlock once per session, done."

## evaluation

### how well does it solve the goal?

| goal | solved? |
|------|---------|
| no more "i don't have auth" blockers | yes ‚Äî token fetched automatically |
| human stays in flow | yes ‚Äî no manual intervention needed |
| secure | yes ‚Äî explicit trust model, human unlocks |
| declarative | yes ‚Äî key specs in yaml, trust via extends |

### pros

- **friction-free**: push just works
- **secure**: human controls trust chain, explicit unlock
- **composable**: other skills can use keyrack too
- **declarative**: key specs versioned with role, not scattered

### cons

- **one more step to unlock**: human must unlock keyrack per session
- **setup cost**: initial keyrack init + host manifest setup

### edge cases

| edge case | pit of success |
|-----------|----------------|
| keyrack not extended | "please ask a human to `rhx keyrack init --extends .agent/repo=ehmpathy/role=mechanic/keyrack.yml`" |
| keyrack not unlocked | "please ask a human to `rhx keyrack unlock`" |
| key not in host manifest | "please ask a human to `rhx keyrack set --key X`" |

### what could be awkward?

- **unlock per session**: might feel repetitive, but it's the security tradeoff
- **host manifest setup**: first-time friction to register keys on each machine

## summary

the keyrack is invisible, portable infrastructure. skills fetch tokens by name; keyrack looks them up from the host manifest. mechanics never know it's there; they stay focused on the work. the human opts-in once, unlocks once per session, and it just works ‚Äî anywhere. no more "you'll have to do it yourself" ‚Äî just "done" üê¢
