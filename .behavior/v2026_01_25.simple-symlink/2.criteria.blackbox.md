# usecase.1 = create relative symlink
given('mechanic wants to create a relative symlink from cwd')
  when('--at and --to and --mode relative are provided')
    then('symlink is created at --at path')
      sothat('the symlink file exists where specified')
    then('symlink points to --to via relative path')
      sothat('moving both symlink and target together preserves the link')
    then('readlink shows a relative path, not absolute')
      sothat('the human can verify the mode was applied correctly')

# usecase.2 = create absolute symlink
given('mechanic wants to create an absolute symlink from cwd')
  when('--at and --to and --mode absolute are provided')
    then('symlink is created at --at path')
      sothat('the symlink file exists where specified')
    then('symlink points to --to via absolute path')
      sothat('symlink still points to same location if symlink is moved')
    then('readlink shows an absolute path')
      sothat('the human can verify the mode was applied correctly')

# usecase.3 = mode is required
given('mechanic forgets to specify mode')
  when('--mode is omitted')
    then('command exits with error')
      sothat('mechanic is forced to make an explicit choice')
    then('error message explains mode is required and shows options')
      sothat('mechanic knows how to fix the invocation')

# usecase.4 = clear named args over positional
given('mechanic or human reads the command invocation')
  when('command is invoked with --at and --to')
    then('the intent is self-documenting in the command itself')
      sothat('no need to remember positional arg order like ln -s')
    then('--at clearly indicates "where the symlink is"')
    then('--to clearly indicates "what the symlink points to"')

# usecase.5 = default: fail fast if --at already exists
given('a file or symlink already exists at the --at location')
  when('command is invoked without --idem flag')
    then('command exits with error')
      sothat('existing files are not accidentally overwritten')
    then('error message explains what exists at that path')
    then('error message documents --idem findsert and --idem upsert options')
      sothat('mechanic discovers idempotency feature when they need it')

# usecase.5a = idempotent findsert
given('a symlink already exists at the --at location')
  when('command is invoked with --idem findsert')
    when('existing symlink points to same --to target')
      then('command succeeds silently')
        sothat('repeated invocations are safe')
    when('existing symlink points to different target')
      then('command exits with error')
        sothat('conflicting symlinks are not silently ignored')
      then('error message shows existing target vs requested target')
        sothat('mechanic can see the conflict')

# usecase.5b = idempotent upsert
given('a symlink already exists at the --at location')
  when('command is invoked with --idem upsert')
    then('existing symlink is replaced with new one')
      sothat('symlink always points to --to regardless of prior state')
    then('command succeeds')
      sothat('repeated invocations converge to desired state')

# usecase.5c = --idem with non-symlink file
given('a regular file (not symlink) exists at the --at location')
  when('command is invoked with --idem findsert or --idem upsert')
    then('command exits with error')
      sothat('regular files are never silently deleted')
    then('error message explains a non-symlink file exists')
      sothat('mechanic must explicitly remove it first')

# usecase.6 = handle --to doesn't exist
given('the --to path does not exist')
  when('command is invoked')
    then('symlink is still created (warn, not fail)')
      sothat('symlinks can be created before targets exist')
    then('warning is emitted about non-existent target')
      sothat('mechanic is aware and can verify intent')

# usecase.7 = create parent directories for --at
given('parent directory of --at path does not exist')
  when('command is invoked')
    then('parent directories are created automatically')
      sothat('mechanic doesn\'t need to mkdir -p first')

# usecase.8 = safety within git repo
given('mechanic invokes command')
  when('--at path would be outside git repo root')
    then('command exits with error')
      sothat('symlinks are only created within repo boundaries')
  when('--to path would be outside git repo root')
    then('command exits with error')
      sothat('symlinks only point to targets within repo boundaries')

# usecase.9 = help and usage
given('mechanic is unsure how to use the skill')
  when('--help is provided')
    then('usage examples are shown')
      sothat('mechanic can copy-paste and adapt')
    then('all required args are documented')
    then('mode options (absolute, relative) are explained')
