# research: templates from rhachet-roles-bhuild

## template.1 = shell wrapper + node delegation

**what**: shell skill delegates to TypeScript CLI implementation

**location**: `src/domain.roles/behaver/skills/init.behavior.sh`

**pattern**:
```bash
#!/usr/bin/env bash
# ... header ...
set -euo pipefail
exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.initBehavior())" -- "$@"
```

**citations**:

[1] from `init.behavior.sh`:
```bash
set -euo pipefail
exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.initBehavior())" -- "$@"
```

**relation to wish**: get.package.docs is simpler (curl + jq + file ops) - pure shell is sufficient

---

## template.2 = zod schema for arg validation

**what**: use zod to validate CLI arguments with type safety

**location**: `src/contract/cli/init.behavior.ts`

**pattern**:
```ts
const schemaOfArgs = z.object({
  named: z.object({
    name: z.string(),
    dir: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

**citations**:

[2] from `init.behavior.ts`:
```ts
const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    name: z.string(),
    dir: z.string().optional(),
    open: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

**relation to wish**: overkill for get.package.docs - bash case statement is sufficient for 2 args

---

## template.3 = findsert pattern for idempotency

**what**: create if not found, skip if exists

**location**: `src/domain.operations/behavior/init/initBehaviorDir.ts`

**pattern**:
```ts
// findsert: skip if exists
if (existsSync(targetPath)) {
  kept.push(templateName);
  continue;
}
// ... write file ...
created.push(templateName);
```

**citations**:

[3] from `initBehaviorDir.ts`:
```ts
// findsert: skip if exists
if (existsSync(targetPath)) {
  kept.push(templateName);
  continue;
}

// read template and replace variable
let content = readFileSync(templatePath, 'utf-8');
...
// write template file
writeFileSync(targetPath, content);
created.push(templateName);
```

**relation to wish**: applicable for cache - check cache before fetch, skip if present

---

## template.4 = tree-style output

**what**: visual tree output for created/kept files

**location**: `src/domain.operations/behavior/init/computeOutputTree.ts`

**pattern**:
```
.behavior/v2026_01_31.get-readmes/
  ‚îú‚îÄ ‚ú® 0.wish.md (created)
  ‚îú‚îÄ üëå 1.vision.md (kept)
  ‚îî‚îÄ ‚ú® 2.1.criteria.blackbox.md (created)
```

**citations**:

[4] skill output uses tree structure with emoji status indicators

**relation to wish**: applicable - show cache hit/miss status visually

---

## template.5 = thoughtroute file structure

**what**: behavior-driven thoughtroute with numbered phases

**location**: `src/domain.operations/behavior/init/templates/`

**pattern**:
```
0.wish.md                           # what we want
1.vision.md                         # what it looks like
1.vision.src                        # how to generate vision
2.1.criteria.blackbox.src           # behavioral requirements
2.2.criteria.blackbox.matrix.src    # test matrix
2.3.criteria.blueprint.src          # implementation requirements
3.1.research.*.src                  # research prompts
3.2.distill.*.src                   # distillation prompts
3.3.blueprint.*.src                 # blueprint prompts
4.1.roadmap.*.src                   # roadmap prompts
5.1.execution.*.src                 # execution prompts
```

**citations**:

[5] from templates directory list:
```
0.wish.md
1.vision.md
1.vision.src
2.1.criteria.blackbox.src
2.2.criteria.blackbox.matrix.src
2.3.criteria.blueprint.src
3.1.research.access._.v1.src
3.1.research.claims._.v1.src
...
```

**relation to wish**: we're currently in this thoughtroute!

---

## template.6 = error output pattern

**what**: consistent error output with emoji and suggestions

**location**: `src/contract/cli/init.behavior.ts`

**pattern**:
```ts
console.error('‚õàÔ∏è  error: --open requires an editor name');
console.error('');
console.error('please specify what editor to open with. for example:');
console.error('  --open codium');
```

**citations**:

[6] from `init.behavior.ts`:
```ts
console.error('‚õàÔ∏è  error: --open requires an editor name');
console.error('');
console.error('please specify what editor to open with. for example:');
console.error('  --open codium');
console.error('  --open vim');
console.error('  --open zed');
console.error('  --open code');
process.exit(1);
```

**relation to wish**: applicable - use same error pattern for get.package.docs errors

---

## decision: pure shell vs node delegation

for get.package.docs, pure shell is preferred because:

1. **simplicity** ‚Äî only needs curl, jq, file ops (all built-in to bash)
2. **no build step** ‚Äî shell skills work immediately without compilation
3. **fewer dependencies** ‚Äî no need for node/npm in minimal environments
4. **portability** ‚Äî shell is available everywhere

the node delegation pattern is better for:
- complex arg parse (zod schemas)
- multi-file operations with templates
- rich output format
- operations that benefit from TypeScript type safety

get.package.docs is simple enough that shell suffices.

---

## summary

| template | applicable? | reason |
|----------|-------------|--------|
| shell + node delegation | no | overkill for simple curl/jq/file ops |
| zod arg validation | no | bash case statement is sufficient |
| findsert pattern | yes | cache check before network fetch |
| tree-style output | yes | show cache hit/miss status |
| error output pattern | yes | consistent error messages |
