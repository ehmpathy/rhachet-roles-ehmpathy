# vision: get.package.docs

## the outcome world

### before

a mechanic encounters `iso-price` in the codebase. they vaguely remember it handles money format. they start to write code:

```ts
const price = new IsoPrice({ amount: 1234, currency: 'USD' });
const formatted = price.toString(); // ???
```

they guess at the api. they add boilerplate conversion functions. they miss that `IsoPrice.build()` exists. they don't realize there's a `setPricePrecision` helper. hours later, they discover their code duplicates built-in functionality — or worse, subtly misuses the library.

### after

the mechanic sees `iso-price` and runs:

```sh
rhx get.package.docs readme --of iso-price
```

the readme appears in their terminal. they see the exact usage patterns, the `setPricePrecision` helper, the `asWords` method. they write correct code the first time. no boilerplate. no guesswork.

### the "aha" moment

> "oh, the readme shows exactly how to do this. i was about to write 40 lines that the library already provides."

the value clicks when the mechanic realizes that 5 seconds to read saved 30 minutes of debug and 50 lines of unnecessary code.

## user experience

### usecases

| goal | command | outcome |
|------|---------|---------|
| understand how to use a package | `rhx get.package.docs readme --of test-fns` | readme content displayed |
| explore what a package contains | `rhx get.package.docs filetree --of domain-objects` | file tree of the package |
| check if a feature exists | `rhx get.package.docs readme --of helpful-errors` | scan readme for the feature |

### contract

**input:**
```sh
rhx get.package.docs readme --of $package
rhx get.package.docs filetree --of $package
```

**output:**
- `readme`: the package's readme.md content, formatted for terminal
- `filetree`: the package's directory structure from node_modules

**fallback flow:**
```
readme not found in node_modules?
  → check cache (.refs/get.package.docs/$package.$version.readme.md)
    → not cached?
      → try npm registry api → cache result
        → still not found?
          → suggest: run `rhx get.package.docs filetree --of $package` instead
```

**cache:**
```
.refs/get.package.docs/$package.$version.readme.md
```

on first use, the skill bootstraps `.refs/get.package.docs/.gitignore`:
```
# ignore entire directory (this .gitignore included)
*
```

readmes are cached after first fetch. benefits:
- **speed** — no network latency on repeat calls
- **offline** — works without internet after first fetch
- **persistence** — survives session restarts; new agents reuse prior fetches
- **version-aware** — each version gets its own cache file

### timeline

1. mechanic starts to use unfamiliar package
2. mechanic runs `rhx get.package.docs readme --of $package`
3. mechanic reads usage examples in ~30 seconds
4. mechanic writes correct code on first attempt
5. mechanic avoids boilerplate, avoids bugs, ships faster

## mental model

### how users would describe this

> "it's like `man` pages for npm packages. i just ask for the readme and it shows me how to use it."

> "it's rtfm-as-a-service. the docs are one command away, so i actually read them."

### analogies

- **`man grep`** — instant access to docs, right in the terminal
- **`--help` flag** — but for the full documentation, not just cli args
- **cookbook on the counter** — you don't have to go to the bookshelf; it's right there

### terms

| user says | we say |
|-----------|--------|
| "show me the docs" | `readme` |
| "what's in this package" | `filetree` |
| "how do i use this" | `readme` |

## evaluation

### how well does it solve the goals?

| goal | solved? |
|------|---------|
| make it easy to fetch readmes | yes — one command |
| incentivize docs read | yes — zero friction |
| reduce boilerplate from misuse | yes — correct usage upfront |
| handle absent readmes gracefully | yes — fallback to filetree |

### pros

- **zero friction** — no browser, no npm website, no context switch
- **version-aware** — shows docs for the version actually installed
- **cached** — fetch once, reuse across sessions (until version changes)
- **discoverable** — filetree reveals what's available even without readme
- **pit of success** — the easiest path is also the correct path

### cons

- **readme quality varies** — some packages have poor docs (not our problem to solve)
- **network dependency** — npm api fallback requires internet (first fetch only; cached after)

note: large readmes are not a con — mechanics can chain with grep:
```sh
rhx get.package.docs readme --of big-package | grep -A 10 "usage"
```

### edgecases

| edgecase | handler |
|----------|---------|
| package not installed | error: "package not found in node_modules. install it first." |
| readme not bundled | fallback to npm registry api |
| npm api fails | suggest filetree as alternative |
| package has no readme anywhere | clear message + filetree suggestion |
| monorepo packages | resolve from node_modules path correctly |

### pit of success

the design keeps users successful by:

1. **local first** — fastest, works offline, matches installed version
2. **cache second** — check `.refs/get.package.docs/` before network
3. **graceful fallback** — npm api is transparent to user
4. **always an alternative** — filetree is always available
5. **clear error messages** — user knows exactly what to do next

## the workflow rule

alongside the skill, we add a brief:

```
rule.require.read-package-docs-before-use

before use of any unfamiliar package api:
1. run `rhx get.package.docs readme --of $package`
2. scan for the feature you need
3. use the documented pattern

this prevents:
- reinvention of built-in functionality
- api misuse
- boilerplate that the library already handles
```

the skill makes the rule easy to follow. the rule makes the skill habitual.
