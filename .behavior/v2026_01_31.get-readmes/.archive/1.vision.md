# Vision: get.package.docs

## The Outcome World

### Before
A mechanic encounters a package they need to use. They've seen it before, maybe used it once, but can't quite remember the API. They guess at the syntax, try a few things, copy patterns from elsewhere in the codebase. When it doesn't work, they add workarounds. Boilerplate accumulates. Edge cases get missed. The package had a helper for exactly this use case, but nobody knew because nobody read the docs.

### After
A mechanic encounters a package. Before writing a single line, they run:
```bash
rhx get.package.docs readme --of iso-price
```

The README appears. They see the intended usage patterns, the gotchas, the utilities. They write code that leverages the package as designed. No boilerplate. No workarounds. No reinventing what already exists.

### The "Aha" Moment
"Wait, this package already has a `formatForDisplay` method? I was about to write my own." The value clicks when you realize the 10 lines you were about to write are already a one-liner in the package—if you'd just read the docs first.

---

## User Experience

### Use Cases & Goals

1. **Before using a package** — Check how it's meant to be used
2. **Debugging unexpected behavior** — See if you're using it wrong
3. **Exploring package capabilities** — Discover utilities you didn't know existed
4. **Understanding versioned behavior** — Get docs for the exact version installed

### Contract Inputs & Outputs

**readme suboperation:**
```bash
rhx get.package.docs readme --of <package-name>

# Input:  package name (e.g., "iso-price", "test-fns")
# Output: README.md contents, sourced from:
#         1. node_modules/<package>/README.md (preferred, always matches installed version)
#         2. npm registry API (fallback, for specific installed version)
#         3. Error message suggesting filetree if neither available
```

**filetree suboperation:**
```bash
rhx get.package.docs filetree --of <package-name>

# Input:  package name
# Output: File tree of the package in node_modules
#         Useful when README unavailable or you need to see structure
```

### Timeline

1. Mechanic starts a task involving a package
2. Workflow rule reminds: "Before using any package, check the README"
3. Mechanic runs `rhx get.package.docs readme --of <package>`
4. README loads instantly (from node_modules) or quickly (from npm API)
5. Mechanic scans for relevant patterns, then writes informed code
6. If no README found, fallback to filetree for exploration

---

## Mental Model

### How Users Would Describe This
"It's like `man` pages but for npm packages. One command, get the docs."

### Analogies
- **`man grep`** for bash commands → **`rhx get.package.docs readme --of lodash`** for npm packages
- **IDE hover docs** but in the terminal, for the whole package
- **The README tab on npm** but local-first and version-matched

### Terms
| User says | System uses |
|-----------|-------------|
| "get the docs" | `get.package.docs readme` |
| "what's in this package" | `get.package.docs filetree` |
| "how do I use this" | workflow rule triggers README check |

---

## Evaluation

### How Well Does It Solve the Goals?

| Goal | Solution Fit |
|------|--------------|
| Easy README access | One command, instant result |
| Incentivize reading docs | Workflow rule + frictionless access |
| Reduce boilerplate | Devs discover existing utilities |
| Version accuracy | Sources from installed version first |

### Pros
- **Zero friction** — Single command, no browser switching
- **Version-correct** — Reads from your actual installed version
- **Offline-capable** — node_modules source works without network
- **Discoverable** — filetree fallback when README missing
- **Workflow-integrated** — Rule reminds you before you forget

### Cons
- **README quality varies** — Some packages have poor docs (mitigated by filetree fallback)
- **Network dependency** — npm API fallback requires connectivity
- **Only works for installed packages** — Must be in node_modules or resolvable

### Edge Cases & Pit of Success

| Edge Case | Handling |
|-----------|----------|
| Package not installed | Clear error: "Package not found in node_modules" |
| README missing from node_modules | Falls back to npm API |
| README missing everywhere | Suggests filetree command as alternative |
| Scoped packages (`@org/pkg`) | Fully supported in path resolution |
| Monorepo internal packages | Works if in node_modules |

---

## Testdriving the Contract

```bash
# Common case: installed package with bundled README
$ rhx get.package.docs readme --of test-fns
# → Displays README.md from node_modules/test-fns/README.md

# Fallback case: README not bundled, fetched from npm
$ rhx get.package.docs readme --of some-minimal-pkg
# → Fetches from https://registry.npmjs.org/some-minimal-pkg/<version>
# → Displays readme field from package metadata

# Missing case: no README anywhere
$ rhx get.package.docs readme --of obscure-pkg
# → "Could not find README for obscure-pkg"
# → "Run: rhx get.package.docs filetree --of obscure-pkg"

# Exploration case: see what's in a package
$ rhx get.package.docs filetree --of iso-price
# → node_modules/iso-price/
# →   ├── README.md
# →   ├── package.json
# →   ├── dist/
# →   │   ├── index.js
# →   │   └── ...
# →   └── ...

# Scoped package
$ rhx get.package.docs readme --of @ehmpathy/domain-objects
# → Works identically, resolves @ehmpathy/domain-objects in node_modules
```

---

## Workflow Integration

A `flow.prod` rule enforces the habit:

> **Before using any package, check the README for how to use it.**

This shifts the culture from "guess and iterate" to "read then write"—eliminating a class of bugs that stem from not understanding the tools we already have.
