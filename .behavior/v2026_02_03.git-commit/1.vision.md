# Vision: Git Commit Skill for Mechanics

## The Outcome World

### Before
A human developer asks their AI mechanic to make changes and commit them. Problems:
- The mechanic has unconstrained commit access - no guardrails
- Push happens without explicit human approval
- No way to grant "just one commit" for a specific fix
- Can't chain automated workflows safely (fix â†’ commit â†’ push â†’ watch)
- Attribution unclear: who did the work vs who delegated it

### After
The human controls exactly how many commits the mechanic can make, and whether push is allowed:

```bash
# Human grants permission
$ git.commit.uses set --allow 2 --push allow

# Mechanic uses it
$ git.commit.set --message "fix(auth): handle null token" --push
```

```
ğŸ¢ cowabunga!

ğŸš git.commit.set
â”œâ”€ commit
â”‚  â”œâ”€ header: fix(auth): handle null token
â”‚  â”œâ”€ author: seaturtle[bot] <seaturtle@ehmpathy.com>
â”‚  â””â”€ patron: Vlad <vlad@ehmpathy.com>
â”œâ”€ push: origin/main âœ“
â””â”€ meter
   â””â”€ remaining: 1 (push: allowed)
```

The mechanic has a quota. Each commit decrements it. When it hits zero, the mechanic must ask the human for more.

### The "Aha" Moment
You run a workflow:
```bash
git release --watch || (rhx show.gh.build.errors && git.commit.uses set --allow 1 --push allow)
```

The mechanic sees the CI failure, analyzes errors, fixes the code, commits, pushes, and the cycle continues - all with explicit human-granted permission for exactly one commit+push per iteration.

## User Experience

### Usecase 1: Human grants commit permission
**Goal:** Control how many commits the mechanic can make

```bash
$ git.commit.uses set --allow 3 --push block
```

Output:
```
ğŸ¢ gnarly! thanks human!

ğŸš git.commit.uses set
â””â”€ meter
   â”œâ”€ granted: 3
   â””â”€ push: blocked
```

```bash
$ git.commit.uses set --allow 1 --push allow
```

Output:
```
ğŸ¢ radical! let's ride!

ğŸš git.commit.uses set
â””â”€ meter
   â”œâ”€ granted: 1
   â””â”€ push: allowed
```

```bash
$ git.commit.uses set --allow 0 --push block
```

Output:
```
ğŸ¢ groovy, break time

ğŸš git.commit.uses set
â””â”€ meter
   â””â”€ revoked
```

The `--push` flag is **required** - humans must explicitly decide. No silent defaults.

### Usecase 2: Mechanic makes a commit
**Goal:** Commit changes within granted quota

```bash
$ git.commit.set --message "fix(api): validate input length"
```

Output (no --push â†’ "righteous!"):
```
ğŸ¢ righteous!

ğŸš git.commit.set
â”œâ”€ commit
â”‚  â”œâ”€ header: fix(api): validate input length
â”‚  â”œâ”€ author: seaturtle[bot] <seaturtle@ehmpathy.com>
â”‚  â””â”€ patron: Vlad <vlad@ehmpathy.com>
â”œâ”€ push: skipped
â””â”€ meter
   â””â”€ remaining: 2 (push: blocked)
```

Output (with --push â†’ "cowabunga!"):
```bash
$ git.commit.set --message "fix(api): validate input length" --push
```

```
ğŸ¢ cowabunga!

ğŸš git.commit.set
â”œâ”€ commit
â”‚  â”œâ”€ header: fix(api): validate input length
â”‚  â”œâ”€ author: seaturtle[bot] <seaturtle@ehmpathy.com>
â”‚  â””â”€ patron: Vlad <vlad@ehmpathy.com>
â”œâ”€ push: origin/main âœ“
â””â”€ meter
   â””â”€ remaining: 0 (push: allowed)
```

### Usecase 3: Mechanic checks remaining quota
**Goal:** Know how many commits are available before attempting

```bash
$ git.commit.uses get
```

Output:
```
ğŸ¢ lets check the meter...

ğŸš git.commit.uses
â””â”€ meter
   â”œâ”€ remaining: 2
   â””â”€ push: allowed
```

### Usecase 4: Permission denied
**Goal:** Clear feedback when quota exhausted

```bash
$ git.commit.set --message "another fix"
```

Output:
```
ğŸ¢ bummer dude...

ğŸš git.commit.set
â””â”€ error: no commit uses remaining

ask your human to grant more:
  $ git.commit.uses set --allow N --push allow|block
```

### Usecase 5: Orchestration chaining
**Goal:** Automated fix â†’ commit â†’ push â†’ watch cycles

```bash
# Watch CI, on failure: show errors and grant one commit+push
git release --watch || (rhx show.gh.build.errors && git.commit.uses set --allow 1 --push allow)
```

The mechanic:
1. Sees CI failure
2. Analyzes errors via `rhx show.gh.build.errors`
3. Makes fix
4. Runs `git.commit.set --message "fix: ..." --push`
5. CI re-runs
6. Loop continues with fresh permission grant each iteration

## Mental Model

### How Users Would Describe It
"I give my AI a budget of commits. It spends them as it works. When it runs out, it has to ask me for more. Like giving a kid arcade tokens."

### Analogies
- **Arcade tokens**: You give N tokens, each play costs one, when they're out they ask for more
- **API rate limits**: The mechanic has a quota that decrements with each use
- **Sudo timeout**: Elevated permissions that expire after use

### Terms
| User's Term | Our Term |
|-------------|----------|
| "let it commit" | grant uses |
| "how many left" | remaining uses |
| "can it push" | push permission |
| "it ran out" | quota exhausted |

## Evaluation

### How Well Does It Solve the Goals?

**Goal: Controlled commits** - Solved. Human sets exact quota.

**Goal: Explicit push permission** - Solved. Required flag, no defaults.

**Goal: Orchestration chaining** - Solved. Permission grants integrate with shell pipelines.

**Goal: Clear attribution** - Solved. seaturtle[bot] as author, human as co-author.

**Goal: Feedback loop** - Solved. Each commit shows remaining uses.

### Pros
- Fine-grained control: 1 commit, 5 commits, or none
- Push is always explicit - no accidental pushes
- Integrates with shell workflows via `||` and `&&`
- Clear messaging on permission denied
- Remaining uses shown after each commit
- Attribution preserved (seaturtle[bot] + co-author)

### Cons
- Requires human to grant permission before mechanic can commit
- Extra command to learn (`git.commit.uses`)

### State Storage: `.meter/`

Quota state lives in `.meter/git.commit.uses.jsonc`:
```jsonc
{
  "uses": 2,
  "push": "allow"
}
```

**Security**: The mechanic is denied write access to `.meter/*` via permissions denylist. It can read its quota but cannot grant itself more.

**Git**: `.meter/.gitignore` ignores state files (local-only), `.meter/.readme` explains why the directory exists.

### Edgecases and Pit of Success

| Edgecase | How We Handle It |
|----------|------------------|
| No uses granted | Clear error: "no commit uses remaining" + instructions |
| Push requested but not allowed | Error: "push not allowed in current grant" |
| No git user configured | Error: "cannot determine co-author" + instructions |
| Uses exhausted mid-workflow | Mechanic stops, asks human for more |
| Human forgets `--push` flag | Command fails: "--push allow|block is required" |
| Mechanic tries to modify `.meter/` | Denied by permissions denylist |

The pit of success:
- Humans can't forget about push (required flag)
- Mechanics can't over-commit (quota enforced)
- Each commit shows remaining budget (no surprises)
- Permission denied message tells exactly what to do
