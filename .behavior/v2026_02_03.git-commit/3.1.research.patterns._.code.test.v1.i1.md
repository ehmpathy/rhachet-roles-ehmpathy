# Research: Test Codepath Patterns

## Pattern 1: BDD-style test structure with `test-fns` [REUSE]

### Citation [1]
> File: `src/domain.operations/hooks/decodeDocOutputPath.test.ts:1-7`
```typescript
import { BadRequestError } from 'helpful-errors';
import { getError, given, then, when } from 'test-fns';

import { decodeDocOutputPath } from './decodeDocOutputPath';

describe('decodeDocOutputPath (only considers [doctype]s after the last "/")', () => {
  given('a typical path with [doctype] after the last slash', () => {
```

### Relation to wish
The git-commit skill tests should follow this BDD structure: `given` → `when` → `then` for clear, readable test cases that match the blackbox criteria.

---

## Pattern 2: File naming conventions [REUSE]

### Citation [2]
> File: `jest.unit.config.ts:28-34`
```typescript
testMatch: [
  // note: order matters
  '**/*.test.ts',
  '!**/*.acceptance.test.ts',
  '!**/*.integration.test.ts',
  '!**/.yalc/**',
],
```

### Citation [3]
> File: `jest.integration.config.ts:29`
```typescript
testMatch: ['**/*.integration.test.ts', '!**/.yalc/**'],
```

### Relation to wish
- Unit tests: `*.test.ts` - for pure function tests (message formatting, trailer parsing)
- Integration tests: `*.integration.test.ts` - for tests that touch git (actual commits)

---

## Pattern 3: Test isolation with `genTempDir` [REUSE]

### Citation [4]
> File: `src/domain.roles/mechanic/skills/claude.tools/cpsafe.integration.test.ts:17-22`
```typescript
const runInTempGitRepo = (args: {
  files?: Record<string, string>;
  symlinks?: Record<string, string>;
  cpsafeArgs: string[];
}): { stdout: string; stderr: string; exitCode: number; tempDir: string } => {
  const tempDir = genTempDir({ slug: 'cpsafe-test', git: true });
```

### Relation to wish
Git-commit integration tests need isolated temp git repos. The `genTempDir({ git: true })` pattern creates a temp directory initialized as a git repo - exactly what we need to test commits without polluting real repos.

---

## Pattern 4: Error testing with `getError` [REUSE]

### Citation [5]
> File: `src/domain.operations/hooks/decodeDocOutputPath.test.ts:54-63`
```typescript
when('decoding the path', () => {
  const err = getError(() => decodeDocOutputPath(input));

  then('it throws a BadRequestError', () => {
    expect(err).toBeInstanceOf(BadRequestError);
    expect((err as BadRequestError).message).toMatch(
      /could not find any \[doctype]/i,
    );
  });
});
```

### Relation to wish
The git-commit skill needs error cases tested (no git user configured, nothing to commit). The `getError` helper captures errors synchronously for assertion.

---

## Pattern 5: Case-numbered test organization [REUSE]

### Citation [6]
> File: `src/domain.roles/mechanic/skills/claude.tools/cpsafe.integration.test.ts:57,114,172`
```typescript
given('[case1] positional args (like cp)', () => {
...
given('[case2] named args (--from, --into)', () => {
...
given('[case3] argument validation', () => {
```

### Relation to wish
Use `[caseN]` prefixes to organize test cases by scenario. Makes test output scannable and maps to blackbox criteria usecases.

---

## Pattern 6: Nested `when` with `[tN]` markers [REUSE]

### Citation [7]
> File: `src/domain.roles/mechanic/skills/claude.tools/cpsafe.integration.test.ts:58-70`
```typescript
when('[t0] two positional args provided', () => {
  then('file is copied', () => {
...
when('[t1] named args in reverse order', () => {
```

### Relation to wish
Use `[tN]` markers for test variants within a case. Allows multiple test scenarios per `given` context.

---

## Pattern 7: Shell script testing via `spawnSync` [REUSE]

### Citation [8]
> File: `src/domain.roles/mechanic/skills/claude.tools/cpsafe.integration.test.ts:43-47`
```typescript
const result = spawnSync('bash', [scriptPath, ...args.cpsafeArgs], {
  cwd: tempDir,
  encoding: 'utf-8',
  stdio: ['pipe', 'pipe', 'pipe'],
});
```

### Relation to wish
If the git-commit skill is implemented as a shell script (like cpsafe.sh), use `spawnSync` to invoke it and capture stdout/stderr/exitCode.

---

## Pattern 8: Jest configuration with SWC transform [REUSE]

### Citation [9]
> File: `jest.unit.config.ts:21-23`
```typescript
transform: {
  '^.+\\.(t|j)sx?$': '@swc/jest',
},
```

### Relation to wish
Tests use SWC for fast TypeScript transformation. No special config needed for new test files.

---

## Pattern 9: Setup files for test environment [REUSE]

### Citation [10]
> File: `jest.integration.config.ts:30`
```typescript
setupFilesAfterEnv: ['./jest.integration.env.ts'],
```

### Relation to wish
Integration tests have their own env setup. If git-commit tests need special setup (e.g., mock git config), it can be added to the integration env file.

---

## Summary: Patterns for Git-Commit Skill Tests

| Pattern | Action | Why |
|---------|--------|-----|
| BDD with `test-fns` | [REUSE] | Consistent with repo style |
| `*.test.ts` / `*.integration.test.ts` naming | [REUSE] | Jest config already supports this |
| `genTempDir({ git: true })` | [REUSE] | Isolated git repos for commit tests |
| `getError` helper | [REUSE] | Error case testing |
| `[caseN]` / `[tN]` markers | [REUSE] | Organized test output |
| `spawnSync` for shell scripts | [REUSE] | If skill is shell-based |
| SWC transform | [REUSE] | Already configured |
| Setup files | [REUSE] | Already configured |

No patterns need to be extended or replaced. The existing test infrastructure fully supports the git-commit skill testing needs.
