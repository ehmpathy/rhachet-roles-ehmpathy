# research: test code patterns for brief.compress

**date**: 2026-02-09
**scope**: patterns from this repo relevant to test the brief.compress skill

---

## executive summary

this repo has mature integration test patterns for shell skills that brief.compress should adopt. the key patterns are: bdd structure with given/when/then, isolated git repo test environments via `genTempDir`, skill execution via `spawnSync`, output sanitization for snapshot stability, and comprehensive coverage of success/error cases. most patterns can be reused directly.

---

## pattern.1: bdd test structure

### [REUSE] given/when/then from test-fns

> ```typescript
> import { given, then, when } from 'test-fns';
>
> describe('sedreplace', () => {
>   given('[case1] a git repo with matched files', () => {
>     when('[t0] run with --mode plan', () => {
>       then('shows preview without changes', async () => {
>         // test implementation
>       });
>     });
>
>     when('[t1] run with --mode apply', () => {
>       then('applies changes to files', async () => {
>         // test implementation
>       });
>     });
>   });
> });
> ```
â€” sedreplace.integration.test.ts:1-30 [1]

**for brief.compress**:
- use `given` for scenario setup (file state, model availability)
- use `when` for action (plan mode, apply mode, with flags)
- use `then` for assertions (output content, file creation, stats)
- use `[caseN]` labels for given blocks
- use `[tN]` labels for when blocks

---

## pattern.2: isolated git repo environment

### [REUSE] genTempDir for test isolation

> ```typescript
> import { genTempDir } from '@ehmpathy/tmpdir';
>
> const runInTempGitRepo = (args: {
>   files: Record<string, string>;
>   sedArgs: string[];
> }): { stdout: string; stderr: string; exitCode: number; tempDir: string } => {
>   // create isolated temp dir with git repo
>   const tempDir = genTempDir({ slug: 'sedreplace-test', git: true });
>
>   // create test files
>   for (const [filePath, content] of Object.entries(args.files)) {
>     const fullPath = path.join(tempDir, filePath);
>     fs.mkdirSync(path.dirname(fullPath), { recursive: true });
>     fs.writeFileSync(fullPath, content);
>   }
>
>   // git add and commit
>   execSync('git add -A', { cwd: tempDir });
>   execSync('git commit -m "test files"', { cwd: tempDir });
>
>   // run the skill
>   const result = spawnSync('bash', [scriptPath, ...args.sedArgs], {
>     cwd: tempDir,
>     encoding: 'utf-8',
>     stdio: ['pipe', 'pipe', 'pipe'],
>   });
>
>   return {
>     stdout: result.stdout ?? '',
>     stderr: result.stderr ?? '',
>     exitCode: result.status ?? 1,
>     tempDir,
>   };
> };
> ```
â€” sedreplace.integration.test.ts:32-67 [1]

**for brief.compress**:
- create temp git repos for each test case
- populate with markdown briefs as test fixtures
- git-track files so skill operates correctly
- return tempDir for post-execution assertions
- clean up happens automatically via genTempDir

---

## pattern.3: skill execution via spawnSync

### [REUSE] spawnSync for shell skill invocation

> ```typescript
> import { spawnSync } from 'child_process';
>
> const skillPath = path.join(__dirname, 'sedreplace.sh');
>
> const result = spawnSync('bash', [skillPath, ...args.sedArgs], {
>   cwd: tempDir,
>   encoding: 'utf-8',
>   stdio: ['pipe', 'pipe', 'pipe'],
> });
>
> return {
>   stdout: result.stdout ?? '',
>   stderr: result.stderr ?? '',
>   exitCode: result.status ?? 1,
> };
> ```
â€” sedreplace.integration.test.ts:54-65 [1]

**for brief.compress**:
- use `spawnSync` for synchronous skill execution in tests
- capture stdout, stderr, and exit code
- run in temp directory context
- use `encode: 'utf-8'` for string output

---

## pattern.4: simple skill runner helper

### [REUSE] runSkill helper for simpler tests

> ```typescript
> const runSkill = (
>   args: string,
> ): { stdout: string; stderr: string; exitCode: number } => {
>   const result = spawnSync(
>     'bash',
>     [skillPath, ...args.split(' ').filter(Boolean)],
>     {
>       cwd: process.cwd(),
>       encoding: 'utf-8',
>       stdio: ['pipe', 'pipe', 'pipe'],
>     },
>   );
>   return {
>     stdout: result.stdout ?? '',
>     stderr: result.stderr ?? '',
>     exitCode: result.status ?? 1,
>   };
> };
> ```
â€” get.package.docs.integration.test.ts:12-26 [2]

**for brief.compress**:
- use simpler helper when git repo isolation not needed
- accepts string args for concise test calls
- splits args on space for bash invocation

---

## pattern.5: output sanitization for snapshots

### [REUSE] sanitizeOutput for stable snapshots

> ```typescript
> const sanitizeOutput = (stdout: string): string =>
>   stdout
>     // remove timestamps
>     .replace(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+/g, 'TIMESTAMP')
>     // remove temp directory paths
>     .replace(/\/tmp\/[^\s]+/g, '/tmp/TEMP_DIR')
>     // normalize line ends
>     .replace(/\r\n/g, '\n');
> ```
â€” sedreplace.integration.test.ts:69-75 [1]

**for brief.compress**:
- sanitize timestamps from output
- sanitize temp paths to stable placeholders
- sanitize token counts if they vary (e.g., `tokens: 1234` â†’ `tokens: N`)
- enables snapshot test without flaky failures

---

## pattern.6: exit code assertions

### [REUSE] explicit exit code checks

> ```typescript
> then('exits with code 0', async () => {
>   const { exitCode } = runInTempGitRepo({
>     files: { 'file.ts': 'old content' },
>     sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'apply'],
>   });
>   expect(exitCode).toBe(0);
> });
>
> then('exits with non-zero code', async () => {
>   const { exitCode } = runInTempGitRepo({
>     files: {},
>     sedArgs: ['--old', 'pattern'],
>   });
>   expect(exitCode).not.toBe(0);
> });
> ```
â€” sedreplace.integration.test.ts:120-135 [1]

**for brief.compress**:
- assert exit code 0 for success cases
- assert non-zero exit code for error cases
- test both validation errors and runtime errors

---

## pattern.7: stdout/stderr content assertions

### [REUSE] output content verification

> ```typescript
> then('stdout contains tree output', async () => {
>   const { stdout } = runInTempGitRepo({
>     files: { 'file.ts': 'old value' },
>     sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'plan'],
>   });
>   expect(stdout).toContain('ğŸ¢');
>   expect(stdout).toContain('ğŸš sedreplace');
>   expect(stdout).toContain('old: old');
>   expect(stdout).toContain('new: new');
> });
>
> then('stderr contains error message', async () => {
>   const { stderr, exitCode } = runInTempGitRepo({
>     files: {},
>     sedArgs: [],
>   });
>   expect(exitCode).not.toBe(0);
>   expect(stderr).toContain('error:');
> });
> ```
â€” sedreplace.integration.test.ts:140-160 [1]

**for brief.compress**:
- assert turtle emoji presence in success output
- assert tree structure elements (ğŸš, â”œâ”€, â””â”€)
- assert compression stats in output
- assert error messages in stderr for failures

---

## pattern.8: file creation assertions

### [REUSE] verify output file creation

> ```typescript
> then('creates modified files', async () => {
>   const { tempDir } = runInTempGitRepo({
>     files: { 'src/file.ts': 'old content' },
>     sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'apply'],
>   });
>
>   const content = fs.readFileSync(path.join(tempDir, 'src/file.ts'), 'utf-8');
>   expect(content).toBe('new content');
> });
> ```
â€” sedreplace.integration.test.ts:180-190 [1]

**for brief.compress**:
- verify `.md.min` file is created next to source
- verify `.md.min` content is compressed version
- verify source `.md` file is unchanged
- verify file is not created in plan mode

---

## pattern.9: plan vs apply mode test

### [REUSE] mode-specific behavior coverage

> ```typescript
> given('[case2] plan mode behavior', () => {
>   when('[t0] run with --mode plan', () => {
>     then('shows diff preview', async () => {
>       const { stdout } = runInTempGitRepo({
>         files: { 'file.ts': 'old' },
>         sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'plan'],
>       });
>       expect(stdout).toContain('note: this was a plan');
>     });
>
>     then('does not modify files', async () => {
>       const { tempDir } = runInTempGitRepo({
>         files: { 'file.ts': 'old' },
>         sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'plan'],
>       });
>       const content = fs.readFileSync(path.join(tempDir, 'file.ts'), 'utf-8');
>       expect(content).toBe('old'); // unchanged
>     });
>   });
> });
>
> given('[case3] apply mode behavior', () => {
>   when('[t0] run with --mode apply', () => {
>     then('modifies files', async () => {
>       const { tempDir } = runInTempGitRepo({
>         files: { 'file.ts': 'old' },
>         sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'apply'],
>       });
>       const content = fs.readFileSync(path.join(tempDir, 'file.ts'), 'utf-8');
>       expect(content).toBe('new'); // changed
>     });
>   });
> });
> ```
â€” sedreplace.integration.test.ts:200-240 [1]

**for brief.compress**:
- test plan mode shows preview without file creation
- test apply mode creates `.md.min` files
- verify plan mode message in output
- use separate given blocks for each mode

---

## pattern.10: rhachet passthrough args

### [REUSE] ignore rhachet-injected args

> ```typescript
> then('ignores rhachet passthrough args', async () => {
>   const { exitCode, stdout } = runInTempGitRepo({
>     files: { 'file.ts': 'old' },
>     sedArgs: [
>       '--old', 'old',
>       '--new', 'new',
>       '--repo', 'ehmpathy',
>       '--role', 'mechanic',
>       '--skill', 'sedreplace',
>       '--mode', 'plan',
>     ],
>   });
>   expect(exitCode).toBe(0);
>   expect(stdout).toContain('ğŸ¢');
> });
> ```
â€” sedreplace.integration.test.ts:250-265 [1]

**for brief.compress**:
- test that --repo, --role, --skill args are silently ignored
- test that -- separator is handled
- ensures skill works when invoked via rhachet

---

## pattern.11: glob pattern test

### [REUSE] glob pattern coverage

> ```typescript
> given('[case4] glob filter', () => {
>   when('[t0] run with --glob "*.ts"', () => {
>     then('only processes .ts files', async () => {
>       const { stdout } = runInTempGitRepo({
>         files: {
>           'file.ts': 'old',
>           'file.js': 'old',
>           'file.md': 'old',
>         },
>         sedArgs: ['--old', 'old', '--new', 'new', '--glob', '*.ts', '--mode', 'plan'],
>       });
>       expect(stdout).toContain('file.ts');
>       expect(stdout).not.toContain('file.js');
>       expect(stdout).not.toContain('file.md');
>     });
>   });
> });
> ```
â€” sedreplace.integration.test.ts:280-300 [1]

**for brief.compress**:
- test glob patterns match expected files
- test glob patterns exclude non-matched files
- test glob with no matches produces informative message

---

## pattern.12: snapshot test

### [REUSE] snapshot for output format stability

> ```typescript
> then('output matches snapshot', async () => {
>   const { stdout } = runInTempGitRepo({
>     files: { 'file.ts': 'old content here' },
>     sedArgs: ['--old', 'old', '--new', 'new', '--mode', 'plan'],
>   });
>   const sanitized = sanitizeOutput(stdout);
>   expect(sanitized).toMatchSnapshot();
> });
> ```
â€” sedreplace.integration.test.ts:310-320 [1]

**for brief.compress**:
- snapshot the tree output format
- snapshot compression stats format
- snapshot error message format
- use sanitizeOutput to remove variable data

---

## pattern.13: error case coverage

### [REUSE] comprehensive error test

> ```typescript
> given('[case5] error conditions', () => {
>   when('[t0] required arg absent', () => {
>     then('exits non-zero with helpful error', async () => {
>       const { exitCode, stderr } = runInTempGitRepo({
>         files: { 'file.ts': 'content' },
>         sedArgs: ['--new', 'replacement'], // absent --old
>       });
>       expect(exitCode).not.toBe(0);
>       expect(stderr).toContain('--old');
>       expect(stderr).toContain('required');
>     });
>   });
>
>   when('[t1] invalid mode value', () => {
>     then('exits non-zero with mode error', async () => {
>       const { exitCode, stderr } = runInTempGitRepo({
>         files: { 'file.ts': 'content' },
>         sedArgs: ['--old', 'x', '--new', 'y', '--mode', 'invalid'],
>       });
>       expect(exitCode).not.toBe(0);
>       expect(stderr).toContain('mode');
>       expect(stderr).toContain('plan');
>       expect(stderr).toContain('apply');
>     });
>   });
>
>   when('[t2] no files match pattern', () => {
>     then('exits zero with informative message', async () => {
>       const { exitCode, stdout } = runInTempGitRepo({
>         files: { 'file.ts': 'content' },
>         sedArgs: ['--old', 'nonexistent', '--new', 'y', '--mode', 'plan'],
>       });
>       expect(exitCode).toBe(0);
>       expect(stdout).toContain('no files');
>     });
>   });
> });
> ```
â€” sedreplace.integration.test.ts:330-380 [1]

**for brief.compress**:
- test absent path argument error
- test invalid mode value error
- test file not found error
- test non-markdown file error
- test model not available error

---

## pattern.14: help flag test

### [REUSE] --help output verification

> ```typescript
> given('[case6] help output', () => {
>   when('[t0] run with --help', () => {
>     then('shows usage and exits zero', async () => {
>       const { exitCode, stdout } = runInTempGitRepo({
>         files: {},
>         sedArgs: ['--help'],
>       });
>       expect(exitCode).toBe(0);
>       expect(stdout).toContain('usage:');
>       expect(stdout).toContain('--old');
>       expect(stdout).toContain('--new');
>       expect(stdout).toContain('--mode');
>     });
>   });
> });
> ```
â€” sedreplace.integration.test.ts:390-405 [1]

**for brief.compress**:
- test --help shows usage
- test --help shows all available flags
- test --help exits with code 0

---

## pattern.15: collocated test file

### [REUSE] test file next to source

> ```
> src/domain.roles/mechanic/skills/claude.tools/
> â”œâ”€â”€ sedreplace.sh
> â””â”€â”€ sedreplace.integration.test.ts
> ```
â€” file structure observation [1]

**for brief.compress**:
- place `brief.compress.integration.test.ts` next to `brief.compress.sh`
- or in skills directory if composed of multiple files
- test file name matches source file name

---

## pattern.16: fixture file content

### [EXTEND] test fixture briefs

> ```typescript
> const files = {
>   'src/file.ts': 'const oldValue = 1;',
>   'src/other.ts': 'const otherOld = 2;',
>   'docs/readme.md': '# Old Title',
> };
> ```
â€” sedreplace.integration.test.ts:85-90 [1]

**for brief.compress**:
- extend to create realistic markdown brief fixtures
- include headers, lists, code blocks, inline code
- include patterns that should compress well
- include patterns that should be preserved (e.g., domain terms)
- example fixture:
  ```typescript
  const files = {
    'briefs/rule.example.md': `
  # rule.example

  ## .what
  this is what the rule does and why it matters for the codebase

  ## .why
  the reason this rule exists is to prevent common mistakes

  ## .examples
  \`\`\`ts
  // good example
  const foo = bar();
  \`\`\`
  `,
  };
  ```

---

## pattern.17: compression-specific assertions

### [EXTEND] token count and ratio verification

> (no direct precedent in extant tests)

**for brief.compress**:
- assert output file is smaller than input
- assert token count is reported in output
- assert compression ratio is reported
- assert ratio is within expected bounds
- example:
  ```typescript
  then('reports compression ratio', async () => {
    const { stdout } = runInTempGitRepo({
      files: { 'brief.md': longBriefContent },
      briefArgs: ['brief.md', '--mode', 'apply'],
    });
    expect(stdout).toMatch(/ratio.*\d+(\.\d+)?x/);
  });

  then('compressed file is smaller', async () => {
    const { tempDir } = runInTempGitRepo({
      files: { 'brief.md': longBriefContent },
      briefArgs: ['brief.md', '--mode', 'apply'],
    });
    const originalSize = fs.statSync(path.join(tempDir, 'brief.md')).size;
    const compressedSize = fs.statSync(path.join(tempDir, 'brief.md.min')).size;
    expect(compressedSize).toBeLessThan(originalSize);
  });
  ```

---

## pattern.18: model availability test

### [EXTEND] external dependency check

> (no direct precedent for model availability in extant tests)

**for brief.compress**:
- test behavior when model is not installed
- test graceful error with install instructions
- potentially use mock or skip if model unavailable
- example:
  ```typescript
  given('[case7] model not available', () => {
    when('[t0] model check fails', () => {
      then('reports model not found with instructions', async () => {
        // would need to mock model check or use env var
        const { stderr, exitCode } = runWithAbsentModel({
          files: { 'brief.md': 'content' },
          briefArgs: ['brief.md'],
        });
        expect(exitCode).not.toBe(0);
        expect(stderr).toContain('model not found');
        expect(stderr).toContain('npm install');
      });
    });
  });
  ```

---

## pattern.19: mtime-based skip test

### [EXTEND] staleness detection

> (no direct precedent in extant tests)

**for brief.compress**:
- test that fresh `.md.min` is skipped
- test that stale `.md.min` is recompressed
- test that --force bypasses mtime check
- example:
  ```typescript
  given('[case8] extant .md.min file', () => {
    when('[t0] source is older than .md.min', () => {
      then('skips compression with up-to-date message', async () => {
        const { tempDir, stdout } = runInTempGitRepo({
          files: {
            'brief.md': 'content',
            'brief.md.min': 'compressed',
          },
          briefArgs: ['brief.md'],
        });
        // touch .md.min to make it newer
        const minPath = path.join(tempDir, 'brief.md.min');
        fs.utimesSync(minPath, new Date(), new Date());

        const result = runSkillInDir(tempDir, ['brief.md']);
        expect(result.stdout).toContain('up-to-date');
      });
    });

    when('[t1] --force flag provided', () => {
      then('recompresses regardless of mtime', async () => {
        // similar setup with --force flag
      });
    });
  });
  ```

---

## pattern.20: validation flag test

### [EXTEND] --validate behavior

> (no direct precedent in extant tests)

**for brief.compress**:
- test that --validate runs behavioral equivalence check
- test that validation pass allows emit
- test that validation fail blocks emit
- example:
  ```typescript
  given('[case9] validation mode', () => {
    when('[t0] compression passes validation', () => {
      then('emits file and reports pass', async () => {
        const { stdout, tempDir } = runInTempGitRepo({
          files: { 'brief.md': goodBriefContent },
          briefArgs: ['brief.md', '--validate', '--mode', 'apply'],
        });
        expect(stdout).toContain('validation: pass');
        expect(fs.existsSync(path.join(tempDir, 'brief.md.min'))).toBe(true);
      });
    });

    when('[t1] compression fails validation', () => {
      then('does not emit file and reports fail', async () => {
        const { stdout, stderr, tempDir } = runInTempGitRepo({
          files: { 'brief.md': constraintHeavyContent },
          briefArgs: ['brief.md', '--validate', '--ratio', '20', '--mode', 'apply'],
        });
        expect(stdout).toContain('validation: fail');
        expect(fs.existsSync(path.join(tempDir, 'brief.md.min'))).toBe(false);
      });
    });
  });
  ```

---

## summary by action

| action | count | patterns |
|--------|-------|----------|
| [REUSE] | 15 | bdd structure, genTempDir, spawnSync, runSkill helper, sanitizeOutput, exit codes, stdout/stderr assertions, file creation, plan/apply modes, rhachet passthrough, glob test, snapshots, error cases, help flag, collocated tests |
| [EXTEND] | 5 | fixture briefs, compression assertions, model availability, mtime staleness, validation flag |
| [REPLACE] | 0 | n/a |

---

## citations

1. src/domain.roles/mechanic/skills/claude.tools/sedreplace.integration.test.ts â€” comprehensive shell skill test
2. src/domain.roles/mechanic/skills/get.package.docs.integration.test.ts â€” simpler skill test example

---

ğŸ¢ 15 patterns to reuse, 5 to extend, 0 to replace â€” shell yeah ğŸŒŠ
