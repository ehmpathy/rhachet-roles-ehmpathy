# research: production code patterns for brief.compress

**date**: 2026-02-09
**scope**: patterns from this repo relevant to the brief.compress skill

---

## executive summary

this repo has mature shell skill patterns that brief.compress should adopt. the key patterns are: header documentation, named argument parse, plan/apply modes, turtle emoji tree output, and fail-fast error handle. most patterns can be reused directly; a few need extension for brief-specific needs.

---

## pattern.1: shell skill header

### [REUSE] standard header block

> ```bash
> #!/usr/bin/env bash
> ######################################################################
> # .what = safe find-and-replace across git-tracked files only
> #
> # .why  = enables bulk text replacement without:
> #         - touch of files outside the repo
> #         - modification of untracked files
> #         - accidental command chain attacks
> #
> # usage:
> #   sedreplace.sh --old "pattern" --new "replacement"                        # plan (default)
> #   sedreplace.sh --old "pattern" --new "replacement" --mode plan            # plan (explicit)
> #   sedreplace.sh --old "pattern" --new "replacement" --mode apply           # apply
> #
> # guarantee:
> #   - only operates on git-tracked files (git ls-files)
> #   - plan mode by default (shows diff, no changes)
> #   - requires --mode apply to apply changes
> #   - fail-fast on errors
> ######################################################################
> ```
â€” sedreplace.sh:1-24 [1]

**for brief.compress**:
- apply this exact header format
- declare `.what`, `.why`, `usage`, `guarantee` sections
- include all flag variants in usage examples

---

## pattern.2: fail-fast shell mode

### [REUSE] set strict mode

> ```bash
> set -euo pipefail
> ```
â€” sedreplace.sh:25 [1]

**for brief.compress**:
- use this exact line after shebang and header
- ensures skill exits on first error, unbound vars, or pipe failures

---

## pattern.3: argument parse

### [REUSE] named argument parse with rhachet passthrough

> ```bash
> while [[ $# -gt 0 ]]; do
>   case $1 in
>     --old)
>       OLD_PATTERN="$2"
>       shift 2
>       ;;
>     --new)
>       NEW_PATTERN="$2"
>       shift 2
>       ;;
>     --glob)
>       GLOB_FILTER="$2"
>       shift 2
>       ;;
>     --mode)
>       MODE="$2"
>       shift 2
>       ;;
>     --repo|--role|--skill)
>       # rhachet passthrough args - ignore
>       shift 2
>       ;;
>     --)
>       # args separator - ignore
>       shift
>       ;;
>     *)
>       echo "unknown argument: $1" >&2
>       echo "usage: sedreplace.sh --old 'pattern' --new 'replacement' [--glob '*.ts'] [--mode plan|apply]" >&2
>       exit 1
>       ;;
>   esac
> done
> ```
â€” sedreplace.sh:34-67 [1]

**for brief.compress**:
- reuse this exact parse pattern
- add cases for: `path` (positional or `--path`), `--glob`, `--mode`, `--mech`, `--ratio`, `--validate`, `--force`
- include rhachet passthrough handle (`--repo`, `--role`, `--skill`, `--`)
- report unknown arguments to stderr with exit 1

---

## pattern.4: required argument validation

### [REUSE] validate required args with descriptive errors

> ```bash
> # validate required args
> if [[ -z "$OLD_PATTERN" ]]; then
>   echo "error: --old pattern is required" >&2
>   exit 1
> fi
>
> if [[ "$NEW_PROVIDED" == "false" ]]; then
>   echo "error: --new replacement is required (use --new \"\" for empty replacement)" >&2
>   exit 1
> fi
> ```
â€” sedreplace.sh:69-78 [1]

**for brief.compress**:
- validate that either `path` or `--glob` is provided
- validate `--mode` is `plan` or `apply`
- validate `--ratio` is within 1-20 range
- provide actionable error messages

---

## pattern.5: mode validation

### [REUSE] explicit mode validation

> ```bash
> # validate mode
> if [[ "$MODE" != "plan" && "$MODE" != "apply" ]]; then
>   echo "error: --mode must be 'plan' or 'apply' (got '$MODE')" >&2
>   exit 1
> fi
> ```
â€” sedreplace.sh:80-84 [1]

**for brief.compress**:
- reuse this pattern
- default to `plan` mode for safe preview

---

## pattern.6: git repo validation

### [REUSE] ensure execution within git repo

> ```bash
> # ensure we're in a git repo
> if ! git rev-parse --git-dir > /dev/null 2>&1; then
>   echo "error: not in a git repository" >&2
>   exit 1
> fi
> ```
â€” sedreplace.sh:86-90 [1]

**for brief.compress**:
- reuse for path resolution relative to repo root
- needed for glob patterns and output colocation

---

## pattern.7: plan/apply mode split

### [REUSE] separate plan and apply codepaths

> ```bash
> if [[ "$MODE" == "plan" ]]; then
>   # plan mode: show what would change (no modifications)
>   echo ""
>
>   for file in $FILES_MATCHED; do
>     LINE_COUNT=$(grep -F -c "$OLD_PATTERN" "$file")
>     echo "--- $file ($LINE_COUNT lines) ---"
>     # show the diff that would result
>     sed "s#$OLD_ESCAPED#$NEW_ESCAPED#g" "$file" | diff -u "$file" - || true
>     echo ""
>   done
>
>   echo "note: this was a plan. to apply, re-run with --mode apply"
> else
>   # apply mode: apply changes
>   echo ""
>
>   for file in $FILES_MATCHED; do
>     # apply the change
>     sed -i "s#$OLD_ESCAPED#$NEW_ESCAPED#g" "$file"
>     echo "   updated: $file ($LINE_COUNT lines)"
>   done
> fi
> ```
â€” sedreplace.sh:170-201 [1]

**for brief.compress**:
- plan mode: show token counts, compression ratio preview, diff of removals
- apply mode: write `.md.min` file, report stats

---

## pattern.8: turtle emoji output

### [REUSE] turtle vibes header

> ```bash
> # print turtle emoji + phrase
> # usage: print_turtle_header "cowabunga!"
> print_turtle_header() {
>   local phrase="$1"
>   echo "ğŸ¢ $phrase"
>   echo ""
> }
> ```
â€” output.sh:17-21 [2]

**for brief.compress**:
- use `ğŸ¢ lets see...` for plan mode
- use `ğŸ¢ shell yeah!` for successful apply
- use `ğŸ¢ bummer dude...` for errors

---

## pattern.9: tree output format

### [REUSE] tree root with shell emoji

> ```bash
> # print tree root with shell emoji
> # usage: print_tree_start "git.commit.set"
> print_tree_start() {
>   local command="$1"
>   echo "ğŸš $command"
> }
> ```
â€” output.sh:24-28 [2]

### [REUSE] tree branches and leaves

> ```bash
> # print tree branch (has children)
> # usage: print_tree_branch "commit" [is_last]
> print_tree_branch() {
>   local label="$1"
>   local is_last="${2:-false}"
>   if [[ "$is_last" == "true" ]]; then
>     echo "   â””â”€ $label"
>   else
>     echo "   â”œâ”€ $label"
>   fi
> }
>
> # print tree leaf (no children, with value)
> # usage: print_tree_leaf "header" "fix(api): validate" [prefix] [is_last]
> print_tree_leaf() {
>   local key="$1"
>   local value="$2"
>   local prefix="${3:-â”‚  }"
>   local is_last="${4:-false}"
>   if [[ "$is_last" == "true" ]]; then
>     echo "${prefix}â””â”€ $key: $value"
>   else
>     echo "${prefix}â”œâ”€ $key: $value"
>   fi
> }
> ```
â€” output.sh:30-54 [2]

**for brief.compress**:
```
ğŸš brief.compress
   â”œâ”€ mode: plan
   â”œâ”€ mech: llmlingua/v2/mobilebert
   â”œâ”€ input: path/to/brief.md
   â”œâ”€ ratio: 4x target
   â””â”€ result
      â”œâ”€ tokens.before: 1200
      â”œâ”€ tokens.after: 312
      â””â”€ ratio.actual: 3.8x
```

---

## pattern.10: error tree format

### [REUSE] error output in tree

> ```bash
> # print error in tree format
> # usage: print_tree_error "no commit uses left"
> print_tree_error() {
>   local message="$1"
>   echo "   â””â”€ error: $message"
> }
> ```
â€” output.sh:69-74 [2]

**for brief.compress**:
- use for file not found, model not available, etc

---

## pattern.11: instruction block after error

### [REUSE] actionable remediation

> ```bash
> # print instruction block (after tree)
> # usage: print_instruction "ask your human to grant more:" "  $ git.commit.uses set ..."
> print_instruction() {
>   local header="$1"
>   local command="$2"
>   echo ""
>   echo "$header"
>   echo "$command"
> }
> ```
â€” output.sh:76-84 [2]

**for brief.compress**:
- use for "model not found" with install instructions
- use for validation failure with lower ratio suggestion

---

## pattern.12: cache directory

### [EXTEND] cache for downloaded artifacts

> ```bash
> # constants
> CACHE_DIR=".refs/get.package.docs"
>
> # bootstrap cache directory (findsert pattern)
> _bootstrap_cache() {
>   if [[ ! -d "$CACHE_DIR" ]]; then
>     mkdir -p "$CACHE_DIR"
>   fi
>   if [[ ! -f "$CACHE_DIR/.gitignore" ]]; then
>     echo "*" > "$CACHE_DIR/.gitignore"
>   fi
> }
> ```
â€” get.package.docs.sh:24, 96-103 [3]

**for brief.compress**:
- extend pattern for LLMLingua model cache
- use `.cache/brief.compress/models/` or similar
- add `.gitignore` to exclude cached models from git

---

## pattern.13: subcommand dispatch

### [REUSE] subcommand pattern

> ```bash
> # parse arguments
> SUBCOMMAND=""
> PACKAGE=""
>
> while [[ $# -gt 0 ]]; do
>   case $1 in
>     readme|filetree)
>       SUBCOMMAND="$1"
>       shift
>       ;;
>     --of)
>       PACKAGE="$2"
>       shift 2
>       ;;
> ...
>
> # dispatch subcommand
> case $SUBCOMMAND in
>   readme)
>     _get_readme
>     ;;
>   filetree)
>     _get_filetree
>     ;;
> esac
> ```
â€” get.package.docs.sh:27-46, 164-171 [3]

**for brief.compress**:
- not needed for v1 (single purpose)
- consider for future: `brief.compress`, `brief.validate`, `brief.diff`

---

## pattern.14: source shared output helpers

### [REUSE] source pattern for shared code

> ```bash
> SKILL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
> source "$SKILL_DIR/output.sh"
> ```
â€” git.commit.set.sh:29-30 [4]

**for brief.compress**:
- create `brief.compress/output.sh` with tree helpers
- source from main skill

---

## pattern.15: state file pattern

### [EXTEND] state persistence in .meter/

> ```bash
> REPO_ROOT=$(git rev-parse --show-toplevel)
> METER_DIR="$REPO_ROOT/.meter"
> STATE_FILE="$METER_DIR/git.commit.uses.jsonc"
>
> # read state
> USES=$(jq -r '.uses' "$STATE_FILE")
> ```
â€” git.commit.set.sh:42-44, 165-166 [4]

**for brief.compress**:
- not needed for v1 (stateless compression)
- consider for future: compression history, validation cache

---

## pattern.16: platform detection

### [REUSE] cross-platform compatibility

> ```bash
> # use sed -i for in-place edit
> # note: macOS sed requires -i '' but linux sed uses -i
> if [[ "$(uname)" == "Darwin" ]]; then
>   sed -i '' "s#$OLD_ESCAPED#$NEW_ESCAPED#g" "$file"
> else
>   sed -i "s#$OLD_ESCAPED#$NEW_ESCAPED#g" "$file"
> fi
> ```
â€” sedreplace.sh:190-196 [1]

**for brief.compress**:
- may need for npm/bun invocation differences
- may need for python path resolution

---

## pattern.17: help flag

### [REUSE] --help support

> ```bash
> --help|-h)
>   echo "usage: git.commit.set -m \$'header\\n\\n- body line 1\\n- body line 2' [--mode plan|apply] [--push]"
>   echo ""
>   echo "options:"
>   echo "  --message, -m          multiline commit message (required)"
>   echo "  --mode plan|apply      plan shows preview, apply executes (default: plan)"
>   echo "  --push                 push after commit (requires push permission)"
>   echo "  --help, -h             show this help"
>   exit 0
>   ;;
> ```
â€” git.commit.set.sh:70-81 [4]

**for brief.compress**:
- include comprehensive help with all flags
- document model options and their tradeoffs

---

## pattern.18: empty result handle

### [REUSE] graceful handle of no matches

> ```bash
> if [[ -z "$FILES" ]]; then
>   echo "ğŸ¢ lets see..."
>   echo ""
>   echo "ğŸš sedreplace"
>   echo "   â”œâ”€ old: $OLD_PATTERN"
>   echo "   â”œâ”€ new: $NEW_PATTERN"
>   echo "   â”œâ”€ glob: $GLOB_DISPLAY"
>   echo "   â””â”€ result: no files match the criteria"
>   exit 0
> fi
> ```
â€” sedreplace.sh:117-126 [1]

**for brief.compress**:
- handle glob with no matches gracefully
- exit 0 with informative message (not an error)

---

## pattern.19: progress count

### [REUSE] pre-count for tree header

> ```bash
> # count files and lines (pre-pass for tree header)
> MATCH_COUNT=$(echo "$FILES_MATCHED" | wc -l)
> TOTAL_LINES=0
> for file in $FILES_MATCHED; do
>   LINE_COUNT=$(grep -F -c "$OLD_PATTERN" "$file")
>   TOTAL_LINES=$((TOTAL_LINES + LINE_COUNT))
> done
> ```
â€” sedreplace.sh:143-148 [1]

**for brief.compress**:
- count files before compression loop
- show aggregate stats in tree header

---

## pattern.20: external tool validation

### [REUSE] check tool availability

> ```bash
> # ensure gh cli is available
> if ! command -v gh &> /dev/null; then
>   echo "â›ˆï¸  error: gh cli is not installed"
>   echo "   install: https://cli.github.com/"
>   exit 1
> fi
> ```
â€” show.gh.action.logs.sh:104-109 [5]

**for brief.compress**:
- check for bun or node availability
- check for npm package or python availability
- provide install instructions on failure

---

## summary by action

| action | count | patterns |
|--------|-------|----------|
| [REUSE] | 18 | header, fail-fast, arg parse, validation, mode split, turtle output, tree format, error format, instruction block, source, platform detect, help, empty handle, progress count, tool check |
| [EXTEND] | 2 | cache directory (for model cache), state file (future validation cache) |
| [REPLACE] | 0 | n/a |

---

## citations

1. src/domain.roles/mechanic/skills/claude.tools/sedreplace.sh â€” find-and-replace skill
2. src/domain.roles/mechanic/skills/git.commit/output.sh â€” turtle vibes output helpers
3. src/domain.roles/mechanic/skills/get.package.docs.sh â€” package docs skill
4. src/domain.roles/mechanic/skills/git.commit/git.commit.set.sh â€” commit skill
5. src/domain.roles/mechanic/skills/show.gh.action.logs.sh â€” github actions logs skill

---

ğŸ¢ 18 patterns to reuse, 2 to extend, 0 to replace â€” shell yeah ğŸŒŠ
