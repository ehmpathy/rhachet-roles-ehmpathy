# blackbox criteria: brief.compress

experience boundaries for the brief.compress skill ‚Äî what the user sees, does, and receives.

---

## usecase.1 = compress single brief

```
given(a markdown brief file)
  when(user invokes `rhx brief.compress path/to/brief.md`)
    then(skill reads the source file)
      sothat(content is available for compression)
    then(skill compresses via LLMLingua-2 token classification)
      sothat(redundant tokens are removed while preserving semantic intent)
    then(skill emits `.md.min` file collocated with source)
      sothat(compressed output is discoverable next to original)
    then(skill reports compression stats)
      sothat(user sees tokens before, tokens after, ratio achieved)

given(a markdown brief file)
  when(user invokes `rhx brief.compress path/to/brief.md --mode plan`)
    then(skill shows compression preview without emitting file)
      sothat(user can review before committing changes)
    then(skill shows diff between original and compressed)
      sothat(user can verify what would be removed)
    then(skill shows projected token savings)
      sothat(user can decide whether to proceed)
```

---

## usecase.2 = compress multiple briefs via glob

```
given(a glob pattern matching multiple markdown files)
  when(user invokes `rhx brief.compress --glob "src/**/*.md"`)
    then(skill enumerates all matched files)
      sothat(batch processing scope is clear)
    then(skill compresses each file sequentially)
      sothat(progress is observable)
    then(skill emits `.md.min` file for each source)
      sothat(all compressed outputs are collocated)
    then(skill reports aggregate stats)
      sothat(user sees total tokens saved across all files)

given(a glob pattern that matches no files)
  when(user invokes `rhx brief.compress --glob "nonexistent/**/*.md"`)
    then(skill reports "no files matched pattern")
      sothat(user knows the glob found empty results)
    then(skill exits with informative message, no error)
      sothat(empty match is not treated as failure)
```

---

## usecase.3 = validate compression quality

```
given(a markdown brief file)
  when(user invokes `rhx brief.compress path/to/brief.md --validate`)
    then(skill compresses the file)
      sothat(compressed content is available for validation)
    then(skill runs behavioral equivalence check)
      sothat(semantic preservation is verified)
    then(skill reports validation result: pass or fail)
      sothat(user knows if compression is safe to use)
    then(skill reports specific degradations if any)
      sothat(user can assess whether to accept or reject)

given(a brief where compression degrades behavior)
  when(user invokes `rhx brief.compress path/to/brief.md --validate`)
    then(skill reports validation failure with details)
      sothat(user understands what was lost)
    then(skill suggests lower compression ratio)
      sothat(user has actionable next step)
    then(skill does not emit .md.min by default on validation failure)
      sothat(broken output is not deployed accidentally)
```

---

## usecase.4 = control compression ratio

```
given(a markdown brief file)
  when(user invokes `rhx brief.compress path/to/brief.md --ratio 4`)
    then(skill targets 4x compression)
      sothat(user controls aggressiveness)
    then(skill may achieve ratio above or below target)
      sothat(content-dependent variance is expected)
    then(skill reports actual ratio achieved)
      sothat(user sees reality vs target)

given(a markdown brief file)
  when(user invokes `rhx brief.compress path/to/brief.md --ratio 20`)
    then(skill targets aggressive 20x compression)
      sothat(maximum savings is attempted)
    then(skill warns about potential quality degradation)
      sothat(user is informed of risk)
    then(skill recommends --validate flag)
      sothat(user is nudged toward safe practice)
```

---

## usecase.5 = handle already-compressed briefs

```
given(a brief that already has a collocated .md.min file)
  when(user invokes `rhx brief.compress path/to/brief.md`)
    then(skill detects extant .md.min file)
      sothat(prior compression is recognized)
    then(skill compares source mtime vs .md.min mtime)
      sothat(staleness is detected)
    then(skill recompresses if source is newer)
      sothat(stale output is refreshed)
    then(skill skips if source is older or equal)
      sothat(unnecessary work is avoided)
    then(skill reports "up-to-date" or "recompressed")
      sothat(user knows what happened)

given(a brief that already has a collocated .md.min file)
  when(user invokes `rhx brief.compress path/to/brief.md --force`)
    then(skill recompresses regardless of mtime)
      sothat(user can force regeneration)
    then(skill overwrites extant .md.min)
      sothat(fresh output replaces prior)
```

---

## usecase.6 = error conditions

```
given(a path that does not point to a file)
  when(user invokes `rhx brief.compress nonexistent.md`)
    then(skill reports "file not found: nonexistent.md")
      sothat(user knows the path is invalid)
    then(skill exits with non-zero status)
      sothat(failure is machine-detectable)

given(a path that points to a non-markdown file)
  when(user invokes `rhx brief.compress image.png`)
    then(skill reports "not a markdown file: image.png")
      sothat(user knows why it was rejected)
    then(skill exits with non-zero status)
      sothat(failure is machine-detectable)

given(LLMLingua model is not available)
  when(user invokes `rhx brief.compress path/to/brief.md`)
    then(skill reports "compression model not found")
      sothat(user knows the dependency is absent)
    then(skill provides setup instructions)
      sothat(user has actionable remediation)
    then(skill exits with non-zero status)
      sothat(failure is machine-detectable)
```

---

## exchange experience: inputs

| input | type | required | default | description |
|-------|------|----------|---------|-------------|
| `path` | string | yes (if no --glob) | ‚Äî | file path to compress |
| `--glob` | string | no | ‚Äî | glob pattern for batch compression |
| `--mode` | enum | no | `apply` | `plan` (preview) or `apply` (emit) |
| `--validate` | flag | no | false | run behavioral equivalence check |
| `--ratio` | number | no | 4 | target compression ratio (1-20) |
| `--force` | flag | no | false | recompress even if up-to-date |

---

## exchange experience: outputs

| output | when | format |
|--------|------|--------|
| `.md.min` file | mode=apply, success | collocated with source |
| compression stats | always | tokens before, after, ratio |
| validation result | --validate | pass/fail with details |
| diff preview | mode=plan | unified diff format |
| error message | on failure | descriptive with remediation |

---

## exchange experience: errors

| error | cause | remediation |
|-------|-------|-------------|
| file not found | path does not match a file | check path spelling |
| not a markdown file | file extension is not .md | provide .md file |
| no files matched | glob pattern returned empty | check glob syntax |
| model not found | LLMLingua not installed | run setup command |
| validation failed | compression degraded behavior | use lower --ratio |

---

## boundary conditions

- **minimum file size**: files under 100 tokens may not benefit from compression; skill warns but proceeds
- **maximum file size**: no hard limit; large files compressed in chunks if needed
- **ratio bounds**: --ratio must be 1-20; values outside range are clamped with warning
- **concurrent access**: skill does not lock files; concurrent runs on same file may conflict
- **encoding**: assumes UTF-8; other encodings may produce garbled output

---

üê¢ blackbox = what the user experiences, not how we build it üåä
