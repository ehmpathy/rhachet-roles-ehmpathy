# blackbox criteria: brief.compress with bhrain/sitrep

## usecase.1 = compress a single brief via bhrain/sitrep

given('a markdown brief file with >100 tokens')
  when('compress is invoked with --from $path --via bhrain/sitrep')
    then('output contains tokens.before, tokens.after, and ratio.actual')
      sothat('the human can evaluate compression quality')
    then('tokens.after < tokens.before')
      sothat('compression actually reduced token count')
    then('output is valid markdown')
      sothat('the compressed brief can be consumed by agents')

  when('compress is invoked with --from $path --via bhrain/sitrep --mode apply')
    then('a .min file is emitted collocated with the source')
      sothat('the compressed brief lives next to its source')
    then('.min content matches the previewed output from plan mode')
      sothat('plan and apply produce the same result')

  when('compress is invoked with --from $path --via bhrain/sitrep --into $output')
    then('the compressed output is written to $output instead of $path.min')
      sothat('the human can control where output lands')

## usecase.2 = compress briefs in batch via glob

given('a glob pattern that matches multiple markdown briefs')
  when('compress is invoked with --from "$glob" --via bhrain/sitrep --mode apply')
    then('each matched file gets a collocated .min')
      sothat('batch compression works the same as single file')
    then('aggregate stats are reported (total files, total tokens before/after)')
      sothat('the human can evaluate batch compression quality')

## usecase.3 = $press@$brain convention

given('a --via value in $press@$brain format')
  when('press is bhrain/sitrep and brain is xai/grok/code-fast-1')
    then('compression uses grok code-fast-1 as the brain')
  when('press is bhrain/sitrep and brain is anthropic/claude/sonnet-4')
    then('compression uses claude sonnet-4 as the brain')
  when('press is llmlingua/v2 and brain is tinybert')
    then('compression uses llmlingua tinybert as the brain')
      sothat('the convention works across both compressor families')

given('a --via value of bhrain/sitrep without @brain')
  when('compress is invoked')
    then('brain defaults to xai/grok/code-fast-1')
      sothat('the human doesnt need to specify a brain for the common case')

given('a --via value of just tinybert (no @ separator)')
  when('compress is invoked')
    then('it is treated as shorthand for llmlingua/v2@tinybert')
      sothat('backwards compat is preserved with the current default')

given('a --via value with @ but no press (e.g., @xai/grok/code-fast-1)')
  when('compress is invoked')
    then('it failfasts with "expected format $press@$brain"')
      sothat('malformed mech values are caught early')

## usecase.4 = sitrep template preserves intent

given('a brief about a code practice rule (e.g., rule.require.dependency-injection)')
  when('compressed via bhrain/sitrep')
    then('the compressed output preserves the rule statement')
      sothat('mechanics know what to enforce')
    then('the compressed output preserves at least one positive example')
      sothat('mechanics know what correct code looks like')
    then('the compressed output preserves the enforcement level (blocker/nitpick)')
      sothat('mechanics know the severity')

given('a brief that contains code blocks')
  when('compressed via bhrain/sitrep')
    then('code blocks are preserved in the output')
      sothat('executable examples survive compression')

## usecase.5 = error paths

given('no api key configured for the brain')
  when('compress is invoked with --via bhrain/sitrep')
    then('it failfasts with a clear message about the absent api key')
      sothat('the human knows exactly what to configure')
    then('no .min file is emitted')
      sothat('partial output doesnt pollute the filesystem')

given('an empty brief file (0 tokens)')
  when('compress is invoked')
    then('an empty .min is emitted with 0 tokens')
      sothat('the operation is idempotent on empty input')

given('--from path does not match any files')
  when('compress is invoked')
    then('it failfasts with "no files matched"')
      sothat('the human knows their glob or path was wrong')

given('--into is specified alongside a glob --from')
  when('compress is invoked')
    then('it failfasts with "--into only valid for single file input"')
      sothat('ambiguous output targets are prevented')

## usecase.6 = output format consistency

given('a brief compressed via bhrain/sitrep')
  when('the same brief is compressed via llmlingua/v2@tinybert')
    then('both produce a .min file at the same path')
      sothat('output format is interchangeable regardless of press')
    then('both report tokens.before, tokens.after, and ratio.actual')
      sothat('metrics are comparable across presses')

## usecase.7 = plan vs apply modes

given('a brief file')
  when('compress is invoked without --mode (default)')
    then('mode defaults to plan')
      sothat('no files are written without explicit intent')
    then('output shows what would be emitted but does not write .min')

  when('compress is invoked with --mode plan')
    then('no .min file is written')
    then('compressed content is shown in stdout')

  when('compress is invoked with --mode apply')
    then('.min file is written')
    then('compressed content is shown in stdout')
