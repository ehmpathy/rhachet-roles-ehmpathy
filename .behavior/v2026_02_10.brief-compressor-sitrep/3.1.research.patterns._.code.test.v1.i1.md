# research: test codepath patterns for brief compression

## citations

1. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:1-4` ‚Äî `import { execSync, spawnSync } from 'child_process'; import * as fs from 'fs'; import * as path from 'path'; import { genTempDir, given, then, when } from 'test-fns';`
2. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:12-15` ‚Äî `const skillPath = path.join(__dirname, '../../../../../dist/domain.roles/mechanic/skills/brief.compress/brief.compress.sh');`
3. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:21-26` ‚Äî `const sanitizeOutput = (stdout: string): string => stdout.replace(/\/tmp\/[^\s]+/g, '/tmp/TEMP_DIR').replace(/tokens\.before: \d+/g, 'tokens.before: N').replace(/tokens\.after: \d+/g, 'tokens.after: N').replace(/ratio\.actual: [\d.]+x/g, 'ratio.actual: Nx');`
4. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:80-111` ‚Äî `runInTempGitRepo` helper: creates temp dir via `genTempDir({ slug: ..., git: true })`, writes files, runs `git add . && git commit`, invokes skill via `spawnSync('bash', [skillPath, ...compressArgs])` with 2min timeout
5. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:32-74` ‚Äî `sampleBrief`: realistic markdown content (rule.require.input-context-pattern with .what/.why/.how/.examples sections)
6. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:113-145` ‚Äî `[case1] single markdown brief / [t0] run with --mode plan`: asserts exit code 0, stdout contains turtle emoji + mode/tokens/ratio, verifies no `.md.min` file created
7. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:147-211` ‚Äî `[case1] / [t1] run with --mode apply`: asserts `.md.min` created, compressed size < original, source unchanged, ratio reported
8. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:214-257` ‚Äî `[case2] glob pattern`: asserts all matched files get `.md.min`, reports "no files matched pattern" for empty glob
9. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:259-336` ‚Äî `[case3] extant .md.min file`: asserts stale check (skip if up-to-date), recompress with --force
10. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:338-382` ‚Äî `[case4] error conditions`: file not found exits 1, non-markdown accepted, no path exits 1
11. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:385-412` ‚Äî `[case5] output format / snapshot`: `sanitizeOutput(result.stdout)` fed to `toMatchSnapshot()`, checks turtle emojis
12. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:432-460` ‚Äî `[case7] model selection / --mech tinybert`: asserts stdout contains `mech: llmlingua/v2/tinybert`, invalid mech exits 1
13. `src/domain.roles/mechanic/skills/brief.compress/brief.compress.integration.test.ts:504-588` ‚Äî `[case9] compression effect`: loads real Wikipedia seaturtles fixture from `blackbox/.test/fixtures/wikipedia.seaturtles.txt`, asserts meaningful token reduction (>1.5x), semantic term preservation
14. `src/domain.roles/mechanic/skills/brief.compress/__snapshots__/brief.compress.integration.test.ts.snap:3-18` ‚Äî snapshot: tree-format output with turtle emoji, mode, mech, input, ratio, tokens (sanitized to `N`/`Nx`)
15. `src/domain.operations/guardBorder/imagineIsContentAdmissible.integration.test.ts:1-2` ‚Äî `import { genBrainAtom } from 'rhachet-brains-xai'; import { given, then, useThen, when } from 'test-fns';`
16. `src/domain.operations/guardBorder/imagineIsContentAdmissible.integration.test.ts:14` ‚Äî `const skipIfNoApiKey = !process.env.XAI_API_KEY ? describe.skip : describe;`
17. `src/domain.operations/guardBorder/imagineIsContentAdmissible.integration.test.ts:17` ‚Äî `const brain = genBrainAtom({ slug: 'xai/grok/code-fast-1' });`
18. `src/domain.operations/guardBorder/imagineIsContentAdmissible.integration.test.ts:20-23` ‚Äî `when.repeatably({ attempts: 3, criteria: process.env.CI ? 'SOME' : 'EVERY' })` for non-deterministic LLM outputs
19. `src/domain.operations/guardBorder/imagineIsContentAdmissible.integration.test.ts:52-58` ‚Äî `const result = await imagineIsContentAdmissible({ content }, { brain }); expect(result.decision).toBe('allow');`
20. `src/domain.operations/guardBorder/imagineIsContentAdmissible.integration.test.ts:76-78` ‚Äî `const result = useThen('returns a result', async () => imagineIsContentAdmissible({ content }, { brain }));`
21. `src/domain.operations/guardBorder/imagineIsContentAdmissible.test.ts:15-52` ‚Äî `genMockBrain`: constructs mock brain atom with `jest.fn().mockResolvedValue({ output: { decision, reason }, metrics: { tokens, cost } })`
22. `src/domain.operations/guardBorder/imagineIsContentAdmissible.test.ts:56-68` ‚Äî unit test pattern: `given('content that contains binary data') / when('content has null bytes') / then('returns block with binary reason')` ‚Äî asserts decision, reason, and `expect(context.brain.ask).not.toHaveBeenCalled()`
23. `src/domain.operations/guardBorder/imagineIsContentAdmissible.test.ts:126-155` ‚Äî unit test: `given('valid text content') / when('brain decides to allow')` ‚Äî asserts decision, reason, `brain.ask` called once
24. `src/domain.operations/guardBorder/imagineIsContentAdmissible.test.ts:158-176` ‚Äî unit test: verifies brain receives ENTIRE document in prompt, not truncated sample
25. `src/domain.operations/guardBorder/decideIsContentAdmissible.test.ts:19-52` ‚Äî `genMockBrain`: same shape as imagineIsContentAdmissible mock but typed as `ContextDecideIsContentAdmissible['brain']`
26. `src/domain.operations/guardBorder/decideIsContentAdmissible.test.ts:55-63` ‚Äî temp dir setup: `let tempDir: string; beforeAll(async () => { tempDir = await fs.mkdtemp(...) }); afterAll(async () => { await fs.rm(tempDir, ...) });`
27. `src/domain.operations/guardBorder/decideIsContentAdmissible.test.ts:65-105` ‚Äî unit test: verifies quarantine write on block, no brain call for inadmissible url, quarantine file shape
28. `src/domain.operations/guardBorder/decideIsContentAdmissibleOnWebfetch.test.ts:54-101` ‚Äî adapter unit test: verifies url passthrough, localhost block, no-url scenario
29. `blackbox/.test/invokeHook.ts:5` ‚Äî `import { genTempDir } from 'test-fns';`
30. `blackbox/.test/invokeHook.ts:19-34` ‚Äî `genTestDir`: `genTempDir({ slug, clone: './blackbox/.test/fixtures/repo-with-role', symlink: [{ at: 'node_modules/rhachet-roles-ehmpathy', to: '.' }], git: true })` then `npx rhachet roles link --role mechanic`
31. `blackbox/.test/invokeHook.ts:44-89` ‚Äî `invokePostToolUseHook`: spawns bash hook, pipes stdin, collects stdout/stderr/exit code
32. `blackbox/.test/invokeHook.ts:95-109` ‚Äî `genWebfetchStdin`: generates PostToolUse JSON with `tool_name`, `tool_input`, `tool_response`, `tool_use_id`, `session_id`
33. `blackbox/.test/fixtures/wikipedia.seaturtles.txt` ‚Äî large real-world prose fixture for compression effect tests
34. `package.json:55` ‚Äî `"test:integration:non-cicd": "jest -c ./jest.integration.config.ts --forceExit --verbose --passWithNoTests $([ -z $THOROUGH ] && echo '--changedSince=main')"`

---

## pattern 1: blackbox skill test via spawnSync [REUSE]

the brief.compress integration test invokes the built skill as a subprocess, same as a human would [4]:

```typescript
const result = spawnSync('bash', [skillPath, ...args.compressArgs], {
  cwd: tempDir,
  encoding: 'utf-8',
  stdio: ['pipe', 'pipe', 'pipe'],
  timeout: 120000,
});
```

the skill path points to the `dist/` compiled version [2]:
```typescript
const skillPath = path.join(__dirname,
  '../../../../../dist/domain.roles/mechanic/skills/brief.compress/brief.compress.sh');
```

assertions target observable outputs only: exit code, stdout content, stderr content, and filesystem artifacts (.min files) [6][7][10]. no internal state is inspected.

**relevance**: the bhrain compressor integration tests will follow this exact pattern. the same skill entrypoint (`brief.compress.sh`) is invoked ‚Äî the test just passes `--via bhrain/sitrep@xai/grok/code-fast-1` instead of `--mech tinybert`. blackbox by design.

---

## pattern 2: genTempDir with git init for test isolation [REUSE]

tests create isolated temp directories via `genTempDir` from `test-fns` [1][4]:

```typescript
const tempDir = genTempDir({ slug: 'brief-compress-test', git: true });
```

the `git: true` flag initializes a git repo. files are written, staged, and committed before the skill runs [4]:

```typescript
for (const [filePath, content] of Object.entries(args.files)) {
  fs.mkdirSync(path.dirname(fullPath), { recursive: true });
  fs.writeFileSync(fullPath, content);
}
execSync('git add .', { cwd: tempDir, stdio: 'pipe' });
execSync('git commit -m "initial"', { cwd: tempDir, stdio: 'pipe' });
```

**relevance**: the bhrain tests need the same temp git repo setup. the `runInTempGitRepo` helper can be reused directly ‚Äî or shared between llmlingua and bhrain test suites.

---

## pattern 3: sanitized snapshot for output format verification [REUSE]

volatile values (temp paths, token counts) are replaced with stable placeholders before snapshot comparison [3][11]:

```typescript
const sanitizeOutput = (stdout: string): string =>
  stdout
    .replace(/\/tmp\/[^\s]+/g, '/tmp/TEMP_DIR')
    .replace(/tokens\.before: \d+/g, 'tokens.before: N')
    .replace(/tokens\.after: \d+/g, 'tokens.after: N')
    .replace(/ratio\.actual: [\d.]+x/g, 'ratio.actual: Nx');
```

the snapshot captures the full tree-format output [14]:
```
üê¢ lets see...

üêö brief.compress
   ‚îú‚îÄ mode: plan
   ‚îú‚îÄ mech: llmlingua/v2/tinybert
   ...
```

**relevance**: the bhrain compressor will produce a similar tree output but with the `--via` value instead of `mech: llmlingua/v2/tinybert`. the sanitizer needs extension to handle the `$press@$brain` format. the snapshot verifies the new output shape.

---

## pattern 4: realistic sample brief as test fixture [REUSE]

the test defines a realistic markdown brief inline ‚Äî `sampleBrief` with `.what`/`.why`/`.how`/`.examples` sections and code blocks [5]. this provides content substantial enough to produce meaningful compression.

a larger fixture lives at `blackbox/.test/fixtures/wikipedia.seaturtles.txt` for compression effect tests [13][33].

**relevance**: the bhrain compressor tests need sample briefs that exercise the sitrep template's ability to preserve rule statements, positive examples, and enforcement levels (per usecase.4 in the blackbox criteria). the same `sampleBrief` can serve as the baseline. additional test briefs may be needed for content fidelity assertions.

---

## pattern 5: plan mode vs apply mode assertions [REUSE]

the test suite explicitly verifies both modes [6][7]:

**plan mode** ‚Äî `[case1] / [t0]`:
- exit code 0
- stdout contains tokens + ratio
- `.md.min` file does NOT exist

**apply mode** ‚Äî `[case1] / [t1]`:
- exit code 0
- `.md.min` file exists
- compressed size < original
- source file content unchanged
- ratio reported in stdout

**relevance**: usecase.7 from the blackbox criteria demands the same plan/apply assertions for the bhrain press. same structure, same checks, same invariants.

---

## pattern 6: glob batch compression test [REUSE]

`[case2]` tests glob-based batch compression [8]:

```typescript
compressArgs: ['--glob', 'briefs/*.md', '--mode', 'apply'],
// ...
expect(fs.existsSync(path.join(result.tempDir, 'briefs/rule1.md.min'))).toBe(true);
expect(fs.existsSync(path.join(result.tempDir, 'briefs/rule2.md.min'))).toBe(true);
```

also verifies empty glob returns "no files matched pattern" [8].

**relevance**: usecase.2 demands batch compression via glob. the bhrain tests must verify the same glob behavior with `--via bhrain/sitrep@...`.

---

## pattern 7: staleness check + force override test [REUSE]

`[case3]` tests the mtime-based staleness check [9]:

```typescript
// create .md.min with future mtime
const futureTime = new Date(Date.now() + 10000);
fs.utimesSync(minPath, futureTime, futureTime);
// ... asserts "skip" + "up-to-date" in stdout
```

`--force` flag recompresses regardless of staleness [9]:
```typescript
compressArgs: ['brief.md', '--mode', 'apply', '--force'],
// ... asserts new content != old content
```

**relevance**: staleness and force behavior apply to both presses. the shell orchestrator handles this before engine dispatch, so these tests cover the bhrain path too ‚Äî but only if the shell routes correctly.

---

## pattern 8: error condition tests [REUSE]

`[case4]` covers error paths [10]:

- file not found: exit 1, stderr contains "file not found"
- non-markdown accepted: exit 0, tokens reported
- no path or glob: exit 1, stderr contains "provide a file path or --glob pattern"

**relevance**: usecase.5 demands error path coverage for the bhrain press. additional error cases needed: absent api key (failfast), malformed `--via` format (`@xai/grok/...` without press), `--into` with glob.

---

## pattern 9: api key skip guard for integration tests [REUSE]

the guardBorder integration test skips if the required api key is absent [16]:

```typescript
const skipIfNoApiKey = !process.env.XAI_API_KEY ? describe.skip : describe;

skipIfNoApiKey('with xAI API', () => {
  const brain = genBrainAtom({ slug: 'xai/grok/code-fast-1' });
  // ...
});
```

**relevance**: the bhrain compressor integration tests require api keys. tests that call the real LLM must skip gracefully when keys are absent. this prevents CI failures in environments without api key access.

---

## pattern 10: when.repeatably for non-deterministic LLM output [REUSE]

LLM outputs are probabilistic. the guardBorder integration test uses `when.repeatably` to handle this [18]:

```typescript
when.repeatably({
  attempts: 3,
  criteria: process.env.CI ? 'SOME' : 'EVERY',
})('[t0] content is standard library readme', () => {
  then('returns allow decision', async () => {
    const result = await imagineIsContentAdmissible({ content }, { brain });
    expect(result.decision).toBe('allow');
  });
});
```

in CI, `SOME` passes if at least one of 3 attempts succeeds. locally, `EVERY` demands all 3 pass.

**relevance**: the bhrain compressor produces non-deterministic output. content fidelity tests (usecase.4) that assert "rule statement preserved" or "code blocks preserved" should use `when.repeatably` to tolerate LLM variance.

---

## pattern 11: useThen for shared result across assertions [REUSE]

the guardBorder integration test uses `useThen` to avoid redundant expensive api calls [20]:

```typescript
const result = useThen('returns a result', async () =>
  imagineIsContentAdmissible({ content }, { brain }),
);

then('returns block decision', () => {
  expect(result.decision).toBe('block');
});

then('provides a reason for the block', () => {
  expect(result.reason).toBeDefined();
});
```

one LLM call, multiple assertions.

**relevance**: the bhrain compression integration tests will assert multiple properties of the same compressed output (tokens.before, tokens.after, ratio, content fidelity). `useThen` avoids a redundant LLM call per assertion.

---

## pattern 12: genMockBrain for unit tests [EXTEND]

the guardBorder unit tests construct a mock brain atom with full spec shape [21]:

```typescript
const genMockBrain = (decision: 'allow' | 'block', reason: string | null) => ({
  repo: 'test',
  slug: 'test/mock',
  spec: { cost: { ... }, gain: { size: { context: { tokens: 256_000 } }, ... } },
  ask: jest.fn().mockResolvedValue({
    output: { decision, reason },
    metrics: { tokens: { input: 100, output: 10 }, cost: { total: { usd: 0 } } },
  }),
}) as unknown as ContextImagineIsContentAdmissible['brain'];
```

unit tests then assert logic without real LLM calls: binary data guard, size limit guard, decision passthrough, full document sent to brain [22][23][24].

**relevance**: if the bhrain compressor extracts logic into a separate domain operation (e.g., `imagineCompressedBrief`), it will need a `genMockBrain` for unit tests. the mock shape stays the same ‚Äî only the `output` schema changes from `{ decision, reason }` to the sitrep output shape (`{ compressed: string }`). even if no domain operation is extracted, the mock brain pattern is available for future decomposition.

---

## pattern 13: blackbox acceptance test infra (genTestDir + invokeHook) [REUSE]

the blackbox test infrastructure provides reusable helpers [29-32]:

- `genTestDir`: creates a temp dir with fixture clone, symlinks node_modules, git init, and `rhachet roles link` [30]
- `invokePostToolUseHook`: spawns a bash hook, pipes JSON stdin, collects stdout/stderr/exit code [31]
- `genWebfetchStdin`: generates the expected Claude Code hook JSON format [32]

**relevance**: if the bhrain compressor ever extends to hook-based invocation (e.g., post-save compression), this infrastructure is ready. for the current skill-based invocation, the `runInTempGitRepo` helper (pattern 2) is sufficient.

---

## pattern 14: compression effect test with real-world fixture [REUSE]

`[case9]` loads a real Wikipedia article (~large prose) and asserts [13]:

- meaningful token reduction: `tokensBefore / tokensAfter > 1.5`
- semantic term preservation: `compressedContent.toContain('turtle')` and `.toContain('sea')`
- metrics reported in stdout

**relevance**: the bhrain compressor needs equivalent "does it actually compress?" tests. for the sitrep template, the assertions shift from keyword survival to semantic fidelity ‚Äî "does the compressed brief still contain the rule statement, at least one example, and the enforcement level?" (usecase.4). `when.repeatably` wraps these to handle LLM variance.

---

## pattern 15: mech selection + validation test [EXTEND]

`[case7]` tests model selection via `--mech` [12]:

```typescript
compressArgs: ['brief.md', '--mode', 'plan', '--mech', 'tinybert'],
// ... expect(result.stdout).toContain('mech: llmlingua/v2/tinybert');
```

invalid mech exits non-zero with error message [12].

**relevance**: the `--mech` flag is replaced by `--via`. new tests needed:
- `--via bhrain/sitrep@xai/grok/code-fast-1` routes to bhrain engine
- `--via llmlingua/v2@tinybert` routes to llmlingua engine (backwards compat)
- `--via tinybert` (no `@`) treated as shorthand for `llmlingua/v2@tinybert`
- `--via bhrain/sitrep` (no `@brain`) defaults to `xai/grok/code-fast-1`
- `--via @xai/grok/code-fast-1` (no press) failfasts
- unknown press failfasts

---

## summary: reuse / extend / replace

| # | pattern | verdict | rationale |
|---|---------|---------|-----------|
| 1 | blackbox skill test via spawnSync | **[REUSE]** | same invocation pattern, different `--via` args |
| 2 | genTempDir with git init | **[REUSE]** | same isolation; `runInTempGitRepo` helper reusable |
| 3 | sanitized snapshot for output format | **[REUSE]** | extend sanitizer to handle `$press@$brain` format |
| 4 | realistic sample brief fixture | **[REUSE]** | same brief; add fidelity-focused briefs for usecase.4 |
| 5 | plan vs apply mode assertions | **[REUSE]** | same mode invariants for both presses |
| 6 | glob batch compression test | **[REUSE]** | same glob behavior regardless of press |
| 7 | staleness check + force override | **[REUSE]** | shell handles staleness before engine dispatch |
| 8 | error condition tests | **[REUSE]** | same base errors + new bhrain-specific errors |
| 9 | api key skip guard | **[REUSE]** | skip integration tests when key absent |
| 10 | when.repeatably for LLM variance | **[REUSE]** | essential for content fidelity assertions |
| 11 | useThen for shared results | **[REUSE]** | avoids redundant LLM calls per assertion |
| 12 | genMockBrain for unit tests | **[EXTEND]** | same shape, different output schema for compression |
| 13 | blackbox acceptance infra | **[REUSE]** | available if hook-based invocation added later |
| 14 | compression effect with fixture | **[REUSE]** | shift from keyword to semantic fidelity assertions |
| 15 | mech selection + validation | **[EXTEND]** | `--mech` replaced by `--via` with `$press@$brain` parse |
