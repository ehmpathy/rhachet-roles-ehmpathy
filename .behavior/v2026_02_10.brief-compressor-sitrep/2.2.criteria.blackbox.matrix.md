# blackbox coverage matrix: brief.compress

## matrix.1 = compress operation (usecases 1, 2, 7)

core compression flow across mode, input type, and output target.

| ind: mode | ind: --from | ind: --into | dep: .min written | dep: stdout preview | dep: output location |
|-----------|-------------|-------------|----------------------|---------------------|----------------------|
| (default) | single file | (absent) | no | yes | — |
| plan | single file | (absent) | no | yes | — |
| apply | single file | (absent) | yes | yes | $path.min |
| apply | single file | $output | yes | yes | $output |
| apply | glob (multi) | (absent) | yes (each) | yes (aggregate) | $each.min |
| apply | glob (multi) | $output | **failfast** | — | — |
| plan | glob (multi) | (absent) | no | yes (aggregate) | — |
| plan | glob (multi) | $output | **failfast** | — | — |

## matrix.2 = --via parse convention (usecase 3)

how the `$press@$brain` value is resolved.

| ind: --via value | dep: press resolved | dep: brain resolved | dep: outcome |
|-------------------|----------------------|---------------------|--------------|
| `bhrain/sitrep@xai/grok/code-fast-1` | `bhrain/sitrep` | `xai/grok/code-fast-1` | compress via brain |
| `bhrain/sitrep@anthropic/claude/sonnet-4` | `bhrain/sitrep` | `anthropic/claude/sonnet-4` | compress via brain |
| `bhrain/sitrep` (no @) | `bhrain/sitrep` | `xai/grok/code-fast-1` (default) | compress via brain |
| `llmlingua/v2@tinybert` | `llmlingua/v2` | `tinybert` | compress via llmlingua |
| `llmlingua/v2@xlm-roberta` | `llmlingua/v2` | `xlm-roberta` | compress via llmlingua |
| `tinybert` (no @, no /) | `llmlingua/v2` (default) | `tinybert` | backwards compat shorthand |
| `@xai/grok/code-fast-1` (no press) | — | — | **failfast**: expected format $press@$brain |

## matrix.3 = sitrep content fidelity (usecase 4)

what the sitrep template must preserve in compressed output.

| ind: brief content type | dep: rule statement preserved | dep: positive example preserved | dep: enforcement level preserved | dep: code blocks preserved |
|-------------------------|-------------------------------|--------------------------------|----------------------------------|---------------------------|
| practice rule brief | yes | yes (at least one) | yes | yes (if present) |
| brief with code blocks | — | — | — | yes |

## matrix.4 = error paths (usecase 5)

| ind: error condition | dep: outcome | dep: .min emitted |
|----------------------|--------------|----------------------|
| no api key configured | failfast: clear message about absent key | no |
| empty brief (0 tokens) | emit empty .min | yes (empty) |
| --from matches no files | failfast: "no files matched" | no |
| --into with glob --from | failfast: "--into only valid for single file input" | no |
| --via with absent press | failfast: "expected format $press@$brain" | no |

## matrix.5 = output format consistency (usecase 6)

| ind: press | dep: output path | dep: metrics reported | dep: output format |
|-------------|------------------|-----------------------|--------------------|
| `bhrain/sitrep` | $path.min | tokens.before, tokens.after, ratio.actual | .min |
| `llmlingua/v2` | $path.min | tokens.before, tokens.after, ratio.actual | .min |

both presses produce identical output shape — interchangeable.

---

## gaps

none detected. all meaningful combinations are covered:
- mode x input-type x output-target = fully enumerated (matrix.1)
- mech parse variants = fully enumerated with defaults and malformed (matrix.2)
- error conditions = all surfaced in blackbox criteria (matrix.4)

## decomposition notes

no decomposition needed — all matrices stay at 2-3 independent dimensions. the broadest matrix (matrix.1) has 3 dimensions x 8 rows, which is manageable.
