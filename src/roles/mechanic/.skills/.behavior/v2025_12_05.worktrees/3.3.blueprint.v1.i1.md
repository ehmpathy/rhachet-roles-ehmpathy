# blueprint: git worktree management skills

## overview

implement a dispatcher and three subcommand scripts following the existing skill patterns:
- `git.worktree.sh` - dispatcher for get|set|del subcommands
- `git.worktree.set.sh` - findsert a worktree for a branch
- `git.worktree.del.sh` - remove a worktree
- `git.worktree.get.sh` - list worktrees for the repo

## architecture

### worktree location strategy

```
# from root repo:
@gitroot/../_worktrees/$reponame/$branchname

# from worktree:
(detect _worktrees in path) => reuse same _worktrees/$reponame/
```

### path resolution logic

```bash
GITROOT="$(git rev-parse --show-toplevel)"
REPONAME="$(basename "$GITROOT")"

# detect if we're in a worktree (path contains _worktrees)
if [[ "$GITROOT" == *"_worktrees"* ]]; then
  # extract: /path/to/_worktrees/$reponame -> /path/to/_worktrees/$reponame
  REPO_WORKTREES_DIR="${GITROOT%/*}"  # parent of current worktree
else
  # root repo: compute sibling _worktrees dir
  REPO_WORKTREES_DIR="$(dirname "$GITROOT")/_worktrees/$REPONAME"
fi
```

### branch name sanitization

```bash
# vlad/practs => vlad.practs
WORKTREE_NAME="${BRANCH_NAME//\//.}"
```

---

## file: `git.worktree.sh` (dispatcher)

### header

```
.what = dispatcher for git worktree management
.why  = single entry point for get|set|del subcommands
.how  = routes to git.worktree.{get,set,del}.sh based on subcommand
```

### usage

```bash
git.worktree.sh get                     # list worktrees
git.worktree.sh set <branch>            # findsert worktree
git.worktree.sh set <branch> --open     # findsert + open in codium
git.worktree.sh set <branch> --main     # create from origin/main
git.worktree.sh del <branch>            # remove worktree
```

### behavior

1. parse first arg as `$SUBCOMMAND`
2. validate: must be one of `get|set|del`
3. dispatch to `$SCRIPT_DIR/git.worktree.$SUBCOMMAND.sh` with remaining args
4. if no subcommand or invalid: show usage

### implementation

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SUBCOMMAND="${1:-}"

case "$SUBCOMMAND" in
  get|set|del)
    shift
    exec "$SCRIPT_DIR/git.worktree.$SUBCOMMAND.sh" "$@"
    ;;
  *)
    echo "usage: git.worktree.sh <command> [args]"
    echo ""
    echo "commands:"
    echo "  get              list worktrees for this repo"
    echo "  set <branch>     findsert worktree for branch"
    echo "  del <branch>     remove worktree for branch"
    echo ""
    echo "options (for set):"
    echo "  --open           open worktree in codium after creation"
    echo "  --main           create branch from origin/main"
    exit 1
    ;;
esac
```

---

## file: `git.worktree.set.sh`

### header

```
.what = findsert a git worktree for a branch
.why  = enable parallel work on same repo without nested worktrees
.how  = creates worktree at @gitroot/../_worktrees/$reponame/$branch
```

### usage

```bash
git.worktree.set.sh <branch>           # findsert worktree
git.worktree.set.sh <branch> --open    # findsert + open in codium
git.worktree.set.sh <branch> --main    # create from origin/main
```

### behavior

1. parse args: `$BRANCH`, `--open`, `--main`
2. resolve `$REPO_WORKTREES_DIR` (handle root repo vs worktree)
3. compute `$WORKTREE_PATH = $REPO_WORKTREES_DIR/$WORKTREE_NAME`
4. findsert logic:
   - if worktree exists at path: `[KEEP]`
   - else: `[CREATE]` via `git worktree add`
5. if `--main`: use `-b $BRANCH origin/main`
6. if `--open`: run `codium $WORKTREE_PATH`

### output

```
[CREATE] vlad.practs => /home/vlad/git/_worktrees/myrepo/vlad.practs
```

---

## file: `git.worktree.del.sh`

### header

```
.what = remove a git worktree
.why  = clean up worktrees no longer needed
.how  = removes worktree at @gitroot/../_worktrees/$reponame/$branch
```

### usage

```bash
git.worktree.del.sh <branch>
```

### behavior

1. parse arg: `$BRANCH`
2. resolve `$REPO_WORKTREES_DIR`
3. compute `$WORKTREE_PATH`
4. if worktree exists:
   - `git worktree remove $WORKTREE_PATH`
   - output `[DELETE] vlad.practs`
5. else:
   - output `[SKIP] vlad.practs (not found)`

---

## file: `git.worktree.get.sh`

### header

```
.what = list git worktrees for this repo
.why  = discover existing worktrees
.how  = lists worktrees at @gitroot/../_worktrees/$reponame/
```

### usage

```bash
git.worktree.get.sh
```

### behavior

1. resolve `$REPO_WORKTREES_DIR`
2. if dir exists:
   - list subdirectories
   - for each: output path and branch info
3. else:
   - output `(no worktrees)`

### output format

```
worktrees for myrepo:
  vlad.practs     => /home/vlad/git/_worktrees/myrepo/vlad.practs
  feature.auth    => /home/vlad/git/_worktrees/myrepo/feature.auth
```

---

## file: `git.worktree.common.sh` (shared helper)

extract common logic to a sourced file:

```bash
# git.worktree.common.sh (sourced by all three scripts)
resolve_worktrees_dir() {
  local GITROOT="$(git rev-parse --show-toplevel)"
  local REPONAME="$(basename "$GITROOT")"

  if [[ "$GITROOT" == *"_worktrees"* ]]; then
    # we're in a worktree - reuse same _worktrees dir
    echo "${GITROOT%/*}"
  else
    # root repo - compute sibling _worktrees dir
    echo "$(dirname "$GITROOT")/_worktrees/$REPONAME"
  fi
}
```

---

## test coverage

### test strategy

create `git.worktree.test.sh` that:
1. sets up a temp git repo
2. exercises all three scripts
3. verifies expected behavior
4. cleans up

### test cases

```
# git.worktree.set
- [x] creates worktree when not exists
- [x] keeps worktree when already exists
- [x] --main creates from origin/main
- [x] --open invokes codium (mock or skip in CI)

# git.worktree.del
- [x] removes existing worktree
- [x] skips when worktree not found

# git.worktree.get
- [x] lists existing worktrees
- [x] handles empty (no worktrees)

# path resolution
- [x] from root repo: uses @gitroot/../_worktrees/$reponame
- [x] from worktree: reuses same _worktrees dir
```

---

## file structure after implementation

```
src/roles/mechanic/.skills/
├── git.worktree.sh           # dispatcher (get|set|del)
├── git.worktree.set.sh
├── git.worktree.del.sh
├── git.worktree.get.sh
├── git.worktree.common.sh    # shared path resolution
└── git.worktree.test.sh      # test coverage
```
