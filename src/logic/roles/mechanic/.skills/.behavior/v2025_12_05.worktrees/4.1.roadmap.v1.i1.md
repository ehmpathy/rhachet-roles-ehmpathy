# roadmap: git worktree management skills

## phase 0: shared foundation

- [ ] **0.1** create `git.worktree.common.sh`
  - implements `resolve_worktrees_dir()` function
  - implements `sanitize_branch_name()` function
  - **acceptance**: file exists, is sourced without error
  - **verify**: `source git.worktree.common.sh && resolve_worktrees_dir` outputs a path

- [ ] **0.2** create `git.worktree.sh` dispatcher
  - routes get|set|del to subcommand scripts
  - shows usage on invalid/missing subcommand
  - **acceptance**: `git.worktree.sh` shows usage, `git.worktree.sh get` dispatches
  - **verify**: `git.worktree.sh` exits 1 with usage text

---

## phase 1: get (read-only, safest first)

- [ ] **1.1** create `git.worktree.get.sh`
  - sources `git.worktree.common.sh`
  - resolves `$REPO_WORKTREES_DIR`
  - lists worktrees if dir exists, else "(no worktrees)"
  - **acceptance**: lists worktrees or shows empty message
  - **verify**: `git.worktree.sh get` outputs worktree list or "(no worktrees)"

---

## phase 2: set (create/findsert)

- [ ] **2.1** create `git.worktree.set.sh` basic functionality
  - sources `git.worktree.common.sh`
  - parses `$BRANCH` argument (required)
  - resolves `$REPO_WORKTREES_DIR`
  - computes `$WORKTREE_PATH` with sanitized branch name
  - findserts: `[KEEP]` if exists, `[CREATE]` via `git worktree add` if not
  - **acceptance**: creates worktree at correct path outside repo
  - **verify**:
    - `git.worktree.sh set test/branch` creates `../_worktrees/$repo/test.branch`
    - running again outputs `[KEEP]`

- [ ] **2.2** add `--main` flag to `git.worktree.set.sh`
  - creates branch from `origin/main` instead of current branch
  - uses `git worktree add -b $BRANCH $PATH origin/main`
  - **acceptance**: worktree created with branch based on origin/main
  - **verify**: `git.worktree.sh set feat/new --main` && branch diverges from origin/main

- [ ] **2.3** add `--open` flag to `git.worktree.set.sh`
  - after findsert, runs `codium $WORKTREE_PATH`
  - **acceptance**: codium opens with worktree path
  - **verify**: `git.worktree.sh set test/branch --open` opens editor (manual)

---

## phase 3: del (destructive, last)

- [ ] **3.1** create `git.worktree.del.sh`
  - sources `git.worktree.common.sh`
  - parses `$BRANCH` argument (required)
  - resolves `$REPO_WORKTREES_DIR`
  - computes `$WORKTREE_PATH`
  - if exists: `git worktree remove $PATH` + `[DELETE]`
  - if not: `[SKIP] (not found)`
  - **acceptance**: removes worktree or skips gracefully
  - **verify**:
    - create worktree, then `git.worktree.sh del test/branch` removes it
    - `git.worktree.sh del nonexistent` outputs `[SKIP]`

---

## phase 4: cross-worktree support

- [ ] **4.1** verify path resolution from worktree context
  - run `git.worktree.sh get` from within a worktree
  - should resolve to same `_worktrees/$repo` dir as root repo
  - **acceptance**: same worktrees listed from root repo and from worktree
  - **verify**:
    - `cd $root && git.worktree.sh get` == `cd $worktree && git.worktree.sh get`

- [ ] **4.2** verify set/del from worktree context
  - `git.worktree.sh set another/branch` from within a worktree
  - should create in same `_worktrees/$repo` dir
  - **acceptance**: worktree created in correct shared location
  - **verify**: new worktree appears in `git.worktree.sh get` from both contexts

---

## phase 5: test coverage

- [ ] **5.1** create `git.worktree.test.sh`
  - sets up temp git repo with remote
  - exercises all commands
  - verifies expected outputs
  - cleans up temp dirs
  - **acceptance**: all test cases pass
  - **verify**: `./git.worktree.test.sh` exits 0

### test cases to cover

```
# path resolution
- [ ] from root repo: uses @gitroot/../_worktrees/$reponame
- [ ] from worktree: reuses same _worktrees dir

# git.worktree.get
- [ ] lists existing worktrees
- [ ] handles empty (no worktrees)

# git.worktree.set
- [ ] creates worktree when not exists
- [ ] keeps worktree when already exists
- [ ] --main creates from origin/main
- [ ] --open invokes codium (skip in test, manual verify)

# git.worktree.del
- [ ] removes existing worktree
- [ ] skips when worktree not found
```

---

## phase 6: polish

- [ ] **6.1** make all scripts executable
  - `chmod +x git.worktree*.sh`
  - **verify**: `ls -la git.worktree*.sh` shows executable bit

- [ ] **6.2** update execution summary
  - emit `5.execution.v1.md` documenting what was implemented
  - **verify**: file exists with implementation summary
