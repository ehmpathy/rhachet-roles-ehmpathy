# 🧩 .brief: `cortal.assembly.grammar`

## .what

`cortal.assembly.grammar` defines how **execution primitives** and **conceptual references**
combine into flat, **stepwise semantic expressions**.

It provides a low-level syntax for:

- executing primitives (`<steer>`, `<think>`, `<recall>`)
- referencing semantic units (`[X]`, `[[X]]`)
- expressing flat operations that yield either **single or pooled** outputs

> expressions are always **one level deep** — atomic, interpretable, and
> suitable for line-by-line execution or inspection.

---

## 🧠 expression structure

Each instruction uses this flat format:

\`\`\`ts
<operation>[input] → [output]
\`\`\`

- `<operation>`: one of the core execution primitives or motion commands
- `[input]`: a **singular** resource
- `[[input]]`: a **plural** resource (a pool)
- `[output]`: result of the operation, may also be singular or plural

> both **input** and **output** may be pools (`[[X]]`) or single items (`[X]`)

---

## 📦 resource forms

| form         | meaning                                 |
|--------------|------------------------------------------|
| `[X]`        | a **singular resource** (concept)        |
| `[[X]]`      | a **plural resource** (pool of concepts) |
| `[Class]`    | abstract type or category                |
| `[example]`  | instance of a class                      |

Examples:

\`\`\`ts
<compare>[[fruit]] → [axis]
<gather>[[claim]] → [[evidence]]
<imagine>[Tool] → [[tool]]
\`\`\`

> `[[X]]` = pool
> `[X]` = single concept

---

## 🧪 example: class to instance pool

\`\`\`ts
<imagine>[Threat] → [[threat]]
\`\`\`

- `[Threat]` is a class
- `[[threat]]` is a **pool** of generated examples
- `<imagine>` returns **many plausible manifestations**, not one

---

## 🧠 roles in the grammar

| element       | role                          | example                  |
|---------------|-------------------------------|---------------------------|
| `<op>`        | execution primitive            | `<decompose>`, `<save>`   |
| `[X]`         | singular operand               | `[banana]`, `[Tool]`      |
| `[[X]]`       | plural operand                 | `[[fruit]]`, `[[idea]]`   |
| `→`           | yields                         | motion result             |
| `[Y]`         | singular output                | `[axis]`, `[knife]`       |
| `[[Y]]`       | plural output                  | `[[tool]]`, `[[claim]]`   |
| `"label"`     | memory reference               | `"draft"`, `"goal"`       |

---

## 📏 grammar rules

- ❌ **No nesting:**
  \`\`\`ts
  <compress>(<decompose>[X])    // ❌ invalid
  \`\`\`

- ✅ **Use chaining instead:**
  \`\`\`ts
  <decompose>[bike] → [parts]
  <compress>[parts] → [summary]
  \`\`\`

- ✅ **Use memory for state passing:**
  \`\`\`ts
  <save>("bike")
  <load>("bike") → [bike]
  \`\`\`

---

## 🧩 grammar patterns

| pattern                             | purpose                                |
|-------------------------------------|----------------------------------------|
| `<imagine>[Class] → [[examples]]`   | generate a pool of concept instances   |
| `<compare>[[peers]] → [axis]`       | extract trait from a set               |
| `<steer>[goal]`                     | change focal anchor                    |
| `<recall>(<save>["label"])`         | persist semantic state                 |

---

## 🔁 related briefs

- [`cortal.assemblylang.primitives`](./cortal.assemblylang.primitives.md)
- [`focus.motion.primitives`](./focus.motion.primitives.md)
- [`cortal.focus`](./cortal.focus.md)
- [`questions`](./questions.md)
- [`concept.treestruct`](./concept.treestruct.md)

---
