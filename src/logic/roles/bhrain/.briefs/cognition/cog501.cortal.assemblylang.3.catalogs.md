# 📚 .brief: `cortal.catalogs`

## .what

`cortal.catalogs` are **structured repositories of reusable cognition** —
collections of **semantic tools** that support fast, interpretable reasoning without starting from scratch.

There are two main kinds:

1. **question catalogs** → reusable **motion vectors**
2. **assembly catalogs** → reusable **thought sequences**

> catalogs capture **well-shaped recipes** —
> high-quality, repeatable semantic moves.

---

## ❓ 1. question catalogs

A **question** is a **motion vector** through concept space.
A **question catalog** collects **reusable semantic maneuvers**, each defined only by:

- **motion.vector** → what kind of semantic motion it performs
- **motion.usecases** → when and why this motion is useful

### example entries:

| question                                 | motion.vector                 | motion.usecases                   |
|------------------------------------------|--------------------------------|------------------------------------|
| `what caused this?`                      | `.depth++`                    | causal diagnosis                   |
| `what are alternatives?`                 | `.breadth++`                  | option generation                  |
| `how is this composed?`                  | `.acuity.substruct++`         | structural decomposition           |
| `what’s missing?`                        | `.acuity.attribute++`         | completeness / gap-finding         |
| `is this still true?`                    | `.context.refresh`            | contextual verification            |

> 📍 questions **do not define context or concept** —
> they are **pure motion vectors**, reusable anywhere.

---

## 🛠️ 2. assembly catalogs

An **assembly** is a **compiled thought sequence** —
a stepwise **atomic chain** built from primitives like `<steer>`, `<think>`, and `<recall>`.

An **assembly catalog** collects common **reasonage workflows**
that can be reused, adapted, or parameterized.

### example entries:

#### 🧠 diagnosis loop

\`\`\`ts
<route>([
  ask("what failed?"),
  <think>(<decompose>[system]),
  ask("what caused this part to fail?"),
  <recall>(<save>("hypothesis"))
])
\`\`\`

#### 🎯 selection flow

\`\`\`ts
<route>([
  ask("what are the options?"),
  <fanout>[[option]],
  <compare>[[option]] → [criteria],
  ask("which is most viable?"),
  <choice>({...})
])
\`\`\`

> assemblies are **semantic macros** — reusable atomic chains of thought

---

## 🔁 reuse vs scratch

| method         | advantage                                |
|----------------|-------------------------------------------|
| from scratch   | custom-tailored, cognitively expensive    |
| from catalog   | efficient, proven, semantically smooth    |

> 🧠 good catalogs let you **plug in your content**
> without reinventing the flow.

---

## 🧩 catalog roles

| kind       | unit           | function                            |
|------------|----------------|-------------------------------------|
| `question` | motion vector  | semantic traversal pattern          |
| `assembly` | atomic chain   | procedural thought sequence         |

---

## 🔁 related briefs

- [`questions`](./questions.md)
- [`cortal.assemblylang.primitives`](./cortal.assemblylang.primitives.md)
- [`cortal.execution.instructionset`](./instructionset.md)
- [`cortal.assembly.grammar`](./cortal.assembly.grammar.md)
- [`focus.motion.primitives`](./focus.motion.primitives.md)

---
