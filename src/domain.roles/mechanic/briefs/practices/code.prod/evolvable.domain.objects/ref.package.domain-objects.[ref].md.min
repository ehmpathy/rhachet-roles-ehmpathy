# domain-objects

![test](https://github.com/ehmpathy/domain-objects/workflows/test/badge.svg)
![publish](https://github.com/ehmpathy/domain-objects/workflows/publish/badge.svg)

represent domain objects, leverage domain knowledge, add runtime validation. guided by domain driven design.

## purpose

- formally define domain objects to speak in domain driven manner
- runtime type checking for safer, easier debugging
- leverage domain knowledge in comparisons and schema validation

## install

```sh
npm install --save domain-objects
```

## usage

### literal

```ts
import { DomainLiteral } from 'domain-objects';

interface Address {
  street: string;
  suite: string | null;
  city: string;
  state: string;
  postal: string;
}
class Address extends DomainLiteral<Address> implements Address {}

const austin = new Address({
  street: '123 South Congress',
  suite: null,
  city: 'Austin',
  state: 'Texas',
  postal: '78704',
});
```

### entity

```ts
import { DomainEntity } from 'domain-objects';

interface RocketShip {
  uuid?: string;
  serialNumber: string;
  fuelQuantity: number;
  passengers: number;
  homeAddress: Address;
}
class RocketShip extends DomainEntity<RocketShip> implements RocketShip {
  public static unique = ['serialNumber'];
  public static updatable = ['fuelQuantity', 'homeAddress'];
}

const ship = new RocketShip({
  serialNumber: 'SN5',
  fuelQuantity: 9001,
  passengers: 21,
  homeAddress: new Address({ ... }),
});
```

### event

```ts
import { DomainEvent } from 'domain-objects';

interface AirQualityMeasuredEvent {
  locationUuid: string;
  sensorUuid: string;
  occurredAt: string;
  temperature: string;
  humidity: string;
  pressure: string;
  pm2p5: string;
  pm5p0: string;
  pm10p0: string;
}
class AirQualityMeasuredEvent extends DomainEvent<AirQualityMeasuredEvent> implements AirQualityMeasuredEvent {
  public static unique = ['locationUuid', 'sensorUuid', 'occurredAt'];
}

const event = new AirQualityMeasuredEvent({
  locationUuid: '8e34eb9b-2874-43e0-bc89-73a73d50ac5c',
  sensorUuid: 'a17f7941-1211-44f4-a22a-b61f220527da',
  occurredAt: '2021-07-08T11:13:38.780Z',
  temperature: '31.52Â°C',
  humidity: '27%rh',
  pressure: '29.99bar',
  pm2p5: '9ug/m3',
  pm5p0: '11ug/m3',
  pm10p0: '17ug/m3',
});
```

### runtime validation

```ts
interface Address {
  id?: number;
  galaxy: string;
  solarSystem: string;
  planet: string;
  continent: string;
}
const schema = Joi.object().keys({
  id: Joi.number().optional(),
  galaxy: Joi.string().valid(['Milky Way', 'Andromeda']).required(),
  solarSystem: Joi.string().required(),
  planet: Joi.string().required(),
  continent: Joi.string().required(),
});
class Address extends DomainLiteral<Address> implements Address {
  public static schema = schema; // supports Zod, Yup, and Joi
}

const northAmerica = new Address({
  galaxy: 'Milky Way',
  solarSystem: 'Sun',
  planet: 'Earth',
  continent: 'North America',
}); // passes

const westDolphia = new Address({
  galaxy: 'AndromedA', // fails enum check, throws error
  solarSystem: 'Asparagia',
  planet: 'Dracena',
  continent: 'West Dolphia',
});
```

## reference types

### `RefByPrimary<typeof DomainObject>`

extracts primary key shape.

```ts
import { DomainEntity, RefByPrimary } from 'domain-objects';

interface SeaTurtle {
  uuid?: string;
  seawaterSecurityNumber: string;
  name: string;
}
class SeaTurtle extends DomainEntity<SeaTurtle> implements SeaTurtle {
  public static primary = ['uuid'] as const;
  public static unique = ['seawaterSecurityNumber'] as const;
}

const primaryRef: RefByPrimary<typeof SeaTurtle> = { uuid: 'beefbeef...' }; // valid
```

### `RefByUnique<typeof DomainObject>`

extracts unique key shape.

```ts
const uniqueRef: RefByUnique<typeof SeaTurtle> = { seawaterSecurityNumber: 'ABC-999' }; // valid
```

### `Ref<typeof DomainObject>`

union of primary or unique keys.

```ts
const byPrimary: Ref<typeof EarthWorm> = { uuid: 'beefbeef...' }; // valid
const byUnique: Ref<typeof EarthWorm> = { soilSecurityNumber: 'SOIL-001', wormSegmentNumber: 'SEG-42' }; // valid
```

## nested hydration

auto-instantiate nested domain objects.

```ts
interface PlantPot {
  diameterInInches: number;
}
class PlantPot extends DomainLiteral<PlantPot> implements PlantPot {}

interface PlantOwner {
  name: string;
}
class PlantOwner extends DomainEntity<PlantOwner> implements PlantOwner {}

interface Plant {
  pot: PlantPot;
  owners: PlantOwner[];
  lastWatered: string;
}
class Plant extends DomainEntity<Plant> implements Plant {
  public static nested = { pot: PlantPot, owners: PlantOwner };
}

const plant = new Plant({
  pot: { diameterInInches: 7 }, // auto-hydrated to PlantPot instance
  owners: [{ name: 'bob' }], // auto-hydrated to PlantOwner instances
  lastWatered: 'monday',
});

expect(plant.pot).toBeInstanceOf(PlantPot);
plant.owners.forEach((owner) => expect(owner).toBeInstanceOf(PlantOwner));
```

## utility functions

### `getUniqueIdentifier(obj)`

returns object containing only properties that uniquely identify the domain object.

literals: all non-metadata properties.
entities: properties declared in `.unique`.

### `serialize(value)`

deterministically converts any value to string:
- sorts array items
- sorts object keys
- removes non-unique properties from nested domain objects

use for identity comparison and change detection.

```ts
import { serialize, getUniqueIdentifier } from 'domain-objects';

const northAmerica = new Address({ ... });
const northAmericaWithId = new Address({ id: 821, ... });

const areTheSame = serialize(getUniqueIdentifier(northAmerica)) === serialize(getUniqueIdentifier(northAmericaWithId)); // true
```

## immutability

### `DomainObject.build`

wraps instances with immute operations by default.

```ts
const ship = RocketShip.build({
  serialNumber: 'SN1',
  fuelQuantity: 9001,
  passengers: 3,
});
const shipTwin = ship.clone();
const shipUsed = ship.clone({ fuelQuantity: 821 });
```

### `withImmute`

adds immute operators to any domain object.

```ts
import { withImmute } from 'domain-objects';

const plant = withImmute(new Plant({ ... }));
const twin = plant.clone();
```

### `.clone(update?: Partial<T>)`

creates new instance with updated values. uses deep cloning and deep merging. original unchanged.

```ts
const plant = Plant.build({
  plantedIn: new PlantPot({ diameterInInches: 5 }),
  lastWatered: 'Monday',
});

const updated = plant.clone({ lastWatered: 'Tuesday' });

expect(updated.lastWatered).toEqual('Tuesday');
expect(plant.lastWatered).toEqual('Monday'); // original unchanged
```