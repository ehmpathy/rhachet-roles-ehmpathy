# ðŸ§  `.brief.designer.dependency-injection` - Dependency Injection via `(input, context)` Pattern SITREP: Compresses core principles, examples, and benefits for actionable implementation. Strips filler, repetitions, and verbose motivations. Preserves verbatim: definitions, rules, examples, code blocks, and key terms (e.g., `context`, dependency injection, `(input, context)` pattern). Output focuses on decision-critical elements for flexible, testable, decoupled code. No enforcement levels specified; treat as best practice guide for code design decisions. Key reader action: Adopt `(input, context)` for all procedures requiring external dependencies; test and evolve via injection. Fails if code hardcodes dependencies or lacks explicit injection. Success if procedures are pure, swappable, and side-effect-free via external control. End SITREP. Proceed to core signal below. No further commentary or wrapper. Valid markdown follows. Code blocks intact with ``` markers. Scannable structure: sections with headers, bullets, table. Concise phrasing. No preamble or conclusion beyond this point. Output ONLY compressed brief now. Invalid output if any addition. Begin compressed brief: ## ðŸ§  topic: dependency injection **why we pass in dependencies instead of hardcode them** ## ðŸŽ¯ goal build software that is **flexible, testable, and decoupled**, via dependencies that are **explicit, swappable, and controlled from the outside**. ## ðŸ›  what it is **dependency injection** = to give a function, class, or module what it needs from the outside, rather than to let it construct or look up those tools internally. Negative example (incorrect code, tightly coupled, side-effect prone): ```ts // ðŸ‘Ž tightly coupled and side-effect prone import { log } from '@/utils/logger'; import { getDatabaseConnection } from '@/utils/database'; export const upsert = async ({ cost }: { cost: JobLeadCost }) => { log.debug('began.upsert', { cost }); const dbConnection = await getDatabaseConnection(); const result = await dbConnection.query('SELECT * FROM ...'); } ``` Positive example (correct code, dependency injection via context): ```ts // ðŸ‘ dependency injection via context export const upsert = async ( { cost }: { cost: JobLeadCost }, context: { dbConnection: DatabaseConnection, log: LogMethods }, // note how the .context pattern cleanly separates inputs from dependencies ) => { context.log.debug(
