## .tactic = args:input-context

### .what
enforce procedure args: (input, context?)

### .why
- clarity
- change-resilience
- prevent confusion
- context injection
- domain alignment
- safe refactors

### .where
- all function definitions
- exported and internal functions
- tests, hooks, utils, modules
- exempt: anonymous inline callbacks if scoped

### .how
#### ğŸ‘ required
- functions accept:
  - one input arg (object)
  - optional context arg (object)
- hard requirement
- input no destructuring at boundary
- no function keyword

#### ğŸ‘ forbidden
- over 2 positional args
- non-destructurable inputs
- blend context into input
- inline positional args unless anonymous

## .examples

### ğŸ‘ positive
```ts
// standard
export const genRoute = async (input: { slug: string }, context?: { traceId?: string }) => { ... }

// internal
const updateUser = ({ userId }: { userId: string }, context: { userDao: UserDao }) => { ... }

// test
expect(hasChanges({ before, after })).toBe(true);
```

### ğŸ‘ negative
```ts
export function doThing(a, b, c) {} // ğŸ‘ positional args & function keyword

handleRequest(input, options, env) // ğŸ‘ more than two args

export const getTotal = (invoice) => ... // ğŸ‘ input not typed
```