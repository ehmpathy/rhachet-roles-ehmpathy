# ðŸ§© .brief.lesson: prefer transformer:pipelines over conditional:mazes

## ðŸŒ³ conditional:mazes
treat each case as fork:

```ts
if (dotfileNoExt) {
  return ...
} else if (hasExt) {
  return ...
} else {
  return ...
}
```

- pros: explicit, easy with 2â€“3 cases
- cons: grows fast per edge case, fragmented paths, more tests

> conditionals are maze â€” new cases add turns, easy to get lost.

## ðŸŒŠ transformer:pipelines
normalize data into sequence for transformations:

```ts
return [parts.name, `i${attempt}`, parts.ext.replace(/^\./, '') || null]
  .filter(isPresent)
  .join('.');
```

- pros: handles all files in one flow, future-proof, fewer tests, clear intent
- cons: less explicit on rules, needs discipline

> pipelines are transformers â€” apply stages consistently.

## ðŸ” why pipelines shine
1. fewer parts â€” single expression
2. symmetry â€” all inputs same flow
3. readability â€” see intent immediately
4. testability â€” one flow, many inputs

## ðŸ§© comparison
### conditional:maze
```ts
if (ext) {
  return `${name}.i${attempt}.${ext}`;
}
if (dotfile) {
  return `${base.slice(1)}.i${attempt}`;
}
return `${base}.i${attempt}`;
```

### transformer:pipeline
```ts
return [name, `i${attempt}`, ext?.replace(/^\./, '')]
  .filter(Boolean)
  .join('.');
```

- pipeline covers all cases at once, conditional scatters logic

## ðŸ”‘ general lesson
> prefer transformer:pipelines over conditional:mazes

- replace if/else with optional elements
- use pipeline (map/filter/join)
- outcome: shorter, composable, easier to test