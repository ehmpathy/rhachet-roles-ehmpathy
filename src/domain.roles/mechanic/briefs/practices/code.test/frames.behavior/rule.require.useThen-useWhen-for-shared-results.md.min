# rule.prefer.useThen-and-useWhen-for-shared-results

## .what
use useThen and useWhen from test-fns to capture operation results and share across blocks without let

## .why
- eliminates redundant api calls
- reduces test execution time
- avoids let declarations
- keeps tests focused on assertions

## .variants
| helper    | creates block | shares with           | use case                     |
| --------- | ------------- | --------------------- | ---------------------------- |
| useThen  | yes          | sibling then blocks   | share async result           |
| useWhen  | yes          | sibling when blocks   | track change over actions    |

## .pattern: useThen
use useThen to share operation result across then assertions:

```ts
import { given, then, useThen, when } from 'test-fns';

given('[case1] some scenario', () => {
  when('[t0] operation is executed', () => {
    const result = useThen('it succeeds', async () => expensiveOperation({ input }));
    then('it returns expected output', () => { expect(result.output).toBeDefined(); });
    then('it returns expected metrics', () => { expect(result.metrics.tokens).toBeGreaterThan(0); });
    then('it returns expected cost', () => { expect(result.cost.total).toBeDefined(); });
  });
});
```

## .pattern: useWhen
use useWhen to wrap when block and share result with sibling when blocks for sequential actions:

```ts
import { given, then, useThen, useWhen, when } from 'test-fns';

given('[case1] user registration', () => {
  when('[t0] before any changes', () => {
    then('user does not exist', async () => {
      const user = await findUser({ email: 'test@example.com' });
      expect(user).toBeNull();
    });
  });
  const responseFirst = useWhen('[t1] registration is called', () => {
    const response = useThen('registration succeeds', async () => registerUser({ email: 'test@example.com' }));
    then('user is created', () => { expect(response.status).toEqual('created'); });
    return response;
  });
  when('[t2] registration is repeated', () => {
    const responseSecond = useThen('registration still succeeds', async () => registerUser({ email: 'test@example.com' }));
    then('response is idempotent', () => {
      expect(responseSecond.id).toEqual(responseFirst.id);
      expect(responseSecond.status).toEqual(responseFirst.status);
    });
  });
});
```

## .antipattern
```ts
// ðŸ‘Ž bad - redundant api calls; use useThen instead
when('[t0] operation is executed', () => {
  then('it returns expected output', async () => { const result = await expensiveOperation({ input }); expect(result.output).toBeDefined(); });
  then('it returns expected metrics', async () => { const result = await expensiveOperation({ input }); expect(result.metrics.tokens).toBeGreaterThan(0); });
});

// ðŸ‘Ž bad - let declaration; use useWhen instead
let responseFirst: Response;
when('[t1] registration is called', () => { then('it succeeds', async () => { responseFirst = await registerUser({ email }); }); });
when('[t2] registration is repeated', () => { then('it is idempotent', async () => { const responseSecond = await registerUser({ email }); expect(responseSecond.id).toEqual(responseFirst.id); }); });
```

## .when to use
| scenario                          | use         |
| --------------------------------- | ----------- |
| share async result across assertions | useThen     |
| track change over actions        | useWhen + useThen |
| idempotency verification          | useWhen + useThen |
| before/after state comparisons    | useWhen + useThen |
| integration tests with api calls  | useThen     |

## .note
- useThen creates block
- useWhen wraps block and returns result for siblings
- use useThen inside useWhen for async results
- both return proxy that defers access
- useWhen enables comparisons across steps